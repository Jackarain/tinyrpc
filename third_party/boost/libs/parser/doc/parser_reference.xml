<?xml version="1.0" standalone="yes"?>
<library-reference id="reference"><title>Reference</title><header name="boost/parser/config.hpp">
<macro name="BOOST_PARSER_NO_RUNTIME_ASSERTIONS"><description><para>Boost.Parser uses assertions (<computeroutput>BOOST_ASSERT()</computeroutput>) in several places to indicate that your use of the library has an error in it. All of those places could heve instead been ill-formed code, caught at compile time. It is far quicker and easier to determine exactly where in your code such an error is located if this is a runtime failure; you can just look at the stack in your favorite debugger. However, if you want to make thes kinds of errors always ill-formed code, define this macro. </para></description></macro>
<macro name="BOOST_PARSER_ASSERT" kind="functionlike"><macro-parameter name="condition"/><description><para>Asserts that the given condition is true. If <computeroutput>BOOST_PARSER_NO_RUNTIME_ASSERTIONS</computeroutput> macro is defined by the user, <computeroutput>BOOST_PARSER_ASSERT</computeroutput> expends to a compile-time <computeroutput>static_assert()</computeroutput>. Otherwise, it expands to a run-time <computeroutput>BOOST_ASSERT()</computeroutput>. Note that defining <computeroutput>BOOST_DISABLE_ASSERTS</computeroutput> disables the use of C <computeroutput>assert</computeroutput>, even when <computeroutput>BOOST_ASSERT</computeroutput> is unavailble. </para></description></macro>
<macro name="BOOST_PARSER_DISABLE_CONCEPTS"><description><para>Boost.Parser will automatically use concepts to constrain templates when building in C++20 mode, if the compiler defines <computeroutput>__cpp_lib_concepts</computeroutput>. To disable the use of concepts, define this macro. </para></description></macro>
<macro name="BOOST_PARSER_USE_HANA_TUPLE"><description><para>Define this macro to use <computeroutput>boost::hana::tuple</computeroutput> instead of <computeroutput>std::tuple</computeroutput> throughout Boost.Parser. </para></description></macro>
<macro name="BOOST_PARSER_MAX_AGGREGATE_SIZE"><description><para>Boost.Parser automatically treats aggregate structs as if they were tuples. It uses some metaprogramming to do this. The technique used has a hard limit on the number of data members a struct can have. Re-define this macro to change the hard limit. Note that large values may increase compile times. </para></description></macro>
<macro name="BOOST_PARSER_SUBRANGE"><description><para>The subrange template that is used throughout Boost.Parser. This will be <computeroutput><classname alt="boost::parser::subrange">boost::parser::subrange</classname></computeroutput> in C++17 builds, and <computeroutput>std::ranges::subrange</computeroutput> in all other builds. </para></description></macro>
<macro name="BOOST_PARSER_TRACE_TO_VS_OUTPUT"><description><para>If you are using Visual Studio to run your program, and don't have a terminal in which to observe the output when parsing with <computeroutput>trace::on</computeroutput>, define this macro and you'll see the trace output in the Visual Studio debugger's output panel. This macro has no effect when <computeroutput>_MSC_VER</computeroutput> is not also defined. </para></description></macro>
<macro name="BOOST_PARSER_ALGO_CONSTEXPR"/>
<macro name="BOOST_PARSER_USE_CONCEPTS"/>
<macro name="BOOST_PARSER_USE_STD_TUPLE"/>
<macro name="BOOST_PARSER_CONSTEXPR"/>
<macro name="BOOST_PARSER_TRACE_OSTREAM"/>
</header>
<header name="boost/parser/error_handling.hpp">
<namespace name="boost">
<namespace name="parser">
<struct name="callback_error_handler"><description><para>An error handler that allows users to supply callbacks to handle the reporting of warnings and errors. The reporting of errors and/or warnings can be suppressed by supplying one or both default-constructed callbacks. </para></description><typedef name="callback_type"><type>std::function&lt; <classname>void</classname>(std::string <classname>const</classname> &amp;)&gt;</type></typedef>
<data-member name="error_"><type>callback_type</type></data-member>
<data-member name="warning_"><type>callback_type</type></data-member>
<data-member name="filename_"><type>std::string</type></data-member>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>error_handler_result</type><template>
          <template-type-parameter name="Iter"/>
          <template-type-parameter name="Sentinel"/>
        </template><parameter name="first"><paramtype><classname>Iter</classname></paramtype></parameter><parameter name="last"><paramtype><classname>Sentinel</classname></paramtype></parameter><parameter name="e"><paramtype><classname>parse_error</classname>&lt; <classname>Iter</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter></method>
<method name="diagnose" cv="const"><type><classname>void</classname></type><template>
          <template-type-parameter name="Context"/>
          <template-type-parameter name="Iter"/>
        </template><parameter name="kind"><paramtype>diagnostic_kind</paramtype></parameter><parameter name="message"><paramtype>std::string_view</paramtype></parameter><parameter name="context"><paramtype><classname>Context</classname> <classname>const</classname> &amp;</paramtype></parameter><parameter name="it"><paramtype><classname>Iter</classname></paramtype></parameter></method>
<method name="diagnose" cv="const"><type><classname>void</classname></type><template>
          <template-type-parameter name="Context"/>
        </template><parameter name="kind"><paramtype>diagnostic_kind</paramtype></parameter><parameter name="message"><paramtype>std::string_view</paramtype></parameter><parameter name="context"><paramtype><classname>Context</classname> <classname>const</classname> &amp;</paramtype></parameter></method>
</method-group>
<constructor/>
<constructor><parameter name="error"><paramtype>callback_type</paramtype></parameter><parameter name="warning"><paramtype>callback_type</paramtype><default>callback_type()</default></parameter></constructor>
<constructor><parameter name="filename"><paramtype>std::string_view</paramtype></parameter><parameter name="error"><paramtype>callback_type</paramtype></parameter><parameter name="warning"><paramtype>callback_type</paramtype><default>callback_type()</default></parameter></constructor>
<constructor><parameter name="filename"><paramtype>std::wstring_view</paramtype></parameter><parameter name="error"><paramtype>callback_type</paramtype></parameter><parameter name="warning"><paramtype>callback_type</paramtype><default>callback_type()</default></parameter><description><para>This overload is Windows-only. </para></description></constructor>
</struct><struct name="rethrow_error_handler"><description><para>An error handler that just re-throws any exception generated by the parse. </para></description><method-group name="public member functions">
<method name="operator()" cv="const"><type>error_handler_result</type><template>
          <template-type-parameter name="Iter"/>
          <template-type-parameter name="Sentinel"/>
        </template><parameter name="first"><paramtype><classname>Iter</classname></paramtype></parameter><parameter name="last"><paramtype><classname>Sentinel</classname></paramtype></parameter><parameter name="e"><paramtype><classname>parse_error</classname>&lt; <classname>Iter</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter></method>
<method name="diagnose" cv="const"><type><classname>void</classname></type><template>
          <template-type-parameter name="Context"/>
          <template-type-parameter name="Iter"/>
        </template><parameter name="kind"><paramtype>diagnostic_kind</paramtype></parameter><parameter name="message"><paramtype>std::string_view</paramtype></parameter><parameter name="context"><paramtype><classname>Context</classname> <classname>const</classname> &amp;</paramtype></parameter><parameter name="it"><paramtype><classname>Iter</classname></paramtype></parameter></method>
<method name="diagnose" cv="const"><type><classname>void</classname></type><template>
          <template-type-parameter name="Context"/>
        </template><parameter name="kind"><paramtype>diagnostic_kind</paramtype></parameter><parameter name="message"><paramtype>std::string_view</paramtype></parameter><parameter name="context"><paramtype><classname>Context</classname> <classname>const</classname> &amp;</paramtype></parameter></method>
</method-group>
</struct><struct name="vs_output_error_handler"><inherit access="public">boost::parser::stream_error_handler</inherit><description><para>An error handler that prints to the Visual Studio debugger via calls to <computeroutput>OutputDebugString()</computeroutput>. </para></description><method-group name="public member functions">
</method-group>
<constructor/>
<constructor><parameter name="filename"><paramtype>std::string_view</paramtype></parameter></constructor>
<constructor><parameter name="filename"><paramtype>std::wstring_view</paramtype></parameter></constructor>
</struct>












































































<function name="write_formatted_message"><type>std::ostream &amp;</type><template>
          <template-type-parameter name="Iter"/>
          <template-type-parameter name="Sentinel"/>
        </template><parameter name="os"><paramtype>std::ostream &amp;</paramtype></parameter><parameter name="filename"><paramtype>std::string_view</paramtype></parameter><parameter name="first"><paramtype><classname>Iter</classname></paramtype></parameter><parameter name="it"><paramtype><classname>Iter</classname></paramtype></parameter><parameter name="last"><paramtype><classname>Sentinel</classname></paramtype></parameter><parameter name="message"><paramtype>std::string_view</paramtype></parameter><parameter name="preferred_max_line_length"><paramtype><classname>int64_t</classname></paramtype><default>80</default></parameter><parameter name="max_after_caret"><paramtype><classname>int64_t</classname></paramtype><default>40</default></parameter><description><para>Writes a formatted message (meaning prefixed with the file name, line, and column number) to <computeroutput>os</computeroutput>. </para></description></function>

<function name="write_formatted_expectation_failure_error_message"><type>std::ostream &amp;</type><template>
          <template-type-parameter name="Iter"/>
          <template-type-parameter name="Sentinel"/>
        </template><parameter name="os"><paramtype>std::ostream &amp;</paramtype></parameter><parameter name="filename"><paramtype>std::string_view</paramtype></parameter><parameter name="first"><paramtype><classname>Iter</classname></paramtype></parameter><parameter name="last"><paramtype><classname>Sentinel</classname></paramtype></parameter><parameter name="e"><paramtype><classname>parse_error</classname>&lt; <classname>Iter</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="preferred_max_line_length"><paramtype><classname>int64_t</classname></paramtype><default>80</default></parameter><parameter name="max_after_caret"><paramtype><classname>int64_t</classname></paramtype><default>40</default></parameter><description><para>Writes a formatted parse-expectation failure (meaning prefixed with the file name, line, and column number) to <computeroutput>os</computeroutput>. </para></description></function>

<function name="find_line_position"><type><classname>line_position</classname>&lt; <classname>Iter</classname> &gt;</type><template>
          <template-type-parameter name="Iter"/>
        </template><parameter name="first"><paramtype><classname>Iter</classname></paramtype></parameter><parameter name="it"><paramtype><classname>Iter</classname></paramtype></parameter><description><para>Returns the <computeroutput><classname alt="boost::parser::line_position">line_position</classname></computeroutput> for <computeroutput>it</computeroutput>, counting lines from the beginning of the input <computeroutput>first</computeroutput>. </para></description></function>
<function name="find_line_end"><type><classname>Iter</classname></type><template>
          <template-type-parameter name="Iter"/>
          <template-type-parameter name="Sentinel"/>
        </template><parameter name="it"><paramtype><classname>Iter</classname></paramtype></parameter><parameter name="last"><paramtype><classname>Sentinel</classname></paramtype></parameter><description><para>Returns the iterator to the end of the line in which <computeroutput>it</computeroutput> is found. <sbr/>
 </para></description></function>
</namespace>
</namespace>
</header>
<header name="boost/parser/error_handling_fwd.hpp">
<namespace name="boost">
<namespace name="parser">
<struct name="default_error_handler"><description><para>The error handler used when the user does not specify a custom one. This error handler prints warnings and errors to <computeroutput>std::cerr</computeroutput>, and does not have an associcated filename. </para></description><method-group name="public member functions">
<method name="operator()" cv="const"><type>error_handler_result</type><template>
          <template-type-parameter name="Iter"/>
          <template-type-parameter name="Sentinel"/>
        </template><parameter name="first"><paramtype><classname>Iter</classname></paramtype></parameter><parameter name="last"><paramtype><classname>Sentinel</classname></paramtype></parameter><parameter name="e"><paramtype><classname>parse_error</classname>&lt; <classname>Iter</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><description><para>Handles a <computeroutput><classname alt="boost::parser::parse_error">parse_error</classname></computeroutput> exception thrown during parsing. A formatted parse-expectation failure is printed to <computeroutput>std::cerr</computeroutput>. Always returns <computeroutput>error_handler_result::fail</computeroutput>. </para></description></method>
<method name="diagnose" cv="const"><type><classname>void</classname></type><template>
          <template-type-parameter name="Context"/>
          <template-type-parameter name="Iter"/>
        </template><parameter name="kind"><paramtype>diagnostic_kind</paramtype></parameter><parameter name="message"><paramtype>std::string_view</paramtype></parameter><parameter name="context"><paramtype><classname>Context</classname> <classname>const</classname> &amp;</paramtype></parameter><parameter name="it"><paramtype><classname>Iter</classname></paramtype></parameter><description><para>Prints <computeroutput>message</computeroutput> to <computeroutput>std::cerr</computeroutput>. The diagnostic is printed with the given <computeroutput>kind</computeroutput>, indicating the location as being at <computeroutput>it</computeroutput>. This must be called within a parser semantic action, providing the parse context. </para></description></method>
<method name="diagnose" cv="const"><type><classname>void</classname></type><template>
          <template-type-parameter name="Context"/>
        </template><parameter name="kind"><paramtype>diagnostic_kind</paramtype></parameter><parameter name="message"><paramtype>std::string_view</paramtype></parameter><parameter name="context"><paramtype><classname>Context</classname> <classname>const</classname> &amp;</paramtype></parameter><description><para>Prints <computeroutput>message</computeroutput> to <computeroutput>std::cerr</computeroutput>. The diagnostic is printed with the given <computeroutput>kind</computeroutput>, at no particular location. This must be called within a parser semantic action, providing the parse context. </para></description></method>
</method-group>
<constructor cv="= default"/>
</struct><struct name="line_position"><template>
      <template-type-parameter name="Iter"/>
    </template><description><para>A position within a line, consisting of an iterator to the start of the line, the line number, and the column number. </para></description><data-member name="line_start"><type><classname>Iter</classname></type></data-member>
<data-member name="line_number"><type><classname>int64_t</classname></type></data-member>
<data-member name="column_number"><type><classname>int64_t</classname></type></data-member>
</struct><struct name="parse_error"><template>
      <template-type-parameter name="Iter"/>
    </template><inherit access="public">std::runtime_error</inherit><description><para>The exception thrown when a parse error is encountered, consisting of an iterator to the point of failure, and the name of the failed parser or rule in <computeroutput>what()</computeroutput>. </para></description><data-member name="iter"><type><classname>Iter</classname></type></data-member>
<method-group name="public member functions">
</method-group>
<constructor><parameter name="it"><paramtype><classname>Iter</classname></paramtype></parameter><parameter name="msg"><paramtype>std::string <classname>const</classname> &amp;</paramtype></parameter></constructor>
</struct><struct name="stream_error_handler"><description><para>Prints warnings and errors to the <computeroutput>std::ostream</computeroutput>s provided by the user, or <computeroutput>std::cerr</computeroutput> if neither stream is specified. If a filename is provided, that is used to print all diagnostics. </para></description><method-group name="public member functions">
<method name="operator()" cv="const"><type>error_handler_result</type><template>
          <template-type-parameter name="Iter"/>
          <template-type-parameter name="Sentinel"/>
        </template><parameter name="first"><paramtype><classname>Iter</classname></paramtype></parameter><parameter name="last"><paramtype><classname>Sentinel</classname></paramtype></parameter><parameter name="e"><paramtype><classname>parse_error</classname>&lt; <classname>Iter</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><description><para>Handles a <computeroutput><classname alt="boost::parser::parse_error">parse_error</classname></computeroutput> exception thrown during parsing. A formatted parse-expectation failure is printed to <computeroutput>*err_os_</computeroutput> when <computeroutput>err_os_</computeroutput> is non-null, or <computeroutput>std::cerr</computeroutput> otherwise. Always returns <computeroutput>error_handler_result::fail</computeroutput>. </para></description></method>
<method name="diagnose" cv="const"><type><classname>void</classname></type><template>
          <template-type-parameter name="Context"/>
          <template-type-parameter name="Iter"/>
        </template><parameter name="kind"><paramtype>diagnostic_kind</paramtype></parameter><parameter name="message"><paramtype>std::string_view</paramtype></parameter><parameter name="context"><paramtype><classname>Context</classname> <classname>const</classname> &amp;</paramtype></parameter><parameter name="it"><paramtype><classname>Iter</classname></paramtype></parameter><description><para>Let <computeroutput>std::ostream * s = kind == diagnostic_kind::error : err_os_ : warn_os_</computeroutput>; prints <computeroutput>message</computeroutput> to <computeroutput>*s</computeroutput> when <computeroutput>s</computeroutput> is non-null, or <computeroutput>std::cerr</computeroutput> otherwise. The diagnostic is printed with the given <computeroutput>kind</computeroutput>, indicating the location as being at <computeroutput>it</computeroutput>. This must be called within a parser semantic action, providing the parse context. </para></description></method>
<method name="diagnose" cv="const"><type><classname>void</classname></type><template>
          <template-type-parameter name="Context"/>
        </template><parameter name="kind"><paramtype>diagnostic_kind</paramtype></parameter><parameter name="message"><paramtype>std::string_view</paramtype></parameter><parameter name="context"><paramtype><classname>Context</classname> <classname>const</classname> &amp;</paramtype></parameter><description><para>Let <computeroutput>std::ostream * s = kind == diagnostic_kind::error : err_os_ : warn_os_</computeroutput>; prints <computeroutput>message</computeroutput> to <computeroutput>*s</computeroutput> when <computeroutput>s</computeroutput> is non-null, or <computeroutput>std::cerr</computeroutput> otherwise. The diagnostic is printed with the given <computeroutput>kind</computeroutput>, at no particular location. This must be called within a parser semantic action, providing the parse context. </para></description></method>
</method-group>
<constructor/>
<constructor><parameter name="filename"><paramtype>std::string_view</paramtype></parameter></constructor>
<constructor><parameter name="filename"><paramtype>std::string_view</paramtype></parameter><parameter name="errors"><paramtype>std::ostream &amp;</paramtype></parameter></constructor>
<constructor><parameter name="filename"><paramtype>std::string_view</paramtype></parameter><parameter name="errors"><paramtype>std::ostream &amp;</paramtype></parameter><parameter name="warnings"><paramtype>std::ostream &amp;</paramtype></parameter></constructor>
<constructor><parameter name="filename"><paramtype>std::wstring_view</paramtype></parameter><description><para>This overload is Windows-only. </para></description></constructor>
<constructor><parameter name="filename"><paramtype>std::wstring_view</paramtype></parameter><parameter name="errors"><paramtype>std::ostream &amp;</paramtype></parameter><description><para>This overload is Windows-only. </para></description></constructor>
<constructor><parameter name="filename"><paramtype>std::wstring_view</paramtype></parameter><parameter name="errors"><paramtype>std::ostream &amp;</paramtype></parameter><parameter name="warnings"><paramtype>std::ostream &amp;</paramtype></parameter><description><para>This overload is Windows-only. </para></description></constructor>
</struct><enum name="error_handler_result"><enumvalue name="fail"/><enumvalue name="rethrow"><purpose>Fail the top-level parse. </purpose><description><para>Re-throw the parse error exception. </para></description></enumvalue><description><para>The possible actions to take when a parse error is handled by an error handler. </para></description></enum>
<enum name="diagnostic_kind"><enumvalue name="error"/><enumvalue name="warning"><purpose>An error diagnostic. </purpose><description><para>A warning diagnostic. </para></description></enumvalue><description><para>The kinds of diagnostics that can be handled by an error handler. </para></description></enum>














































































<function name="write_formatted_message"><type>std::ostream &amp;</type><template>
          <template-type-parameter name="Iter"/>
          <template-type-parameter name="Sentinel"/>
        </template><parameter name="os"><paramtype>std::ostream &amp;</paramtype></parameter><parameter name="filename"><paramtype>std::wstring_view</paramtype></parameter><parameter name="first"><paramtype><classname>Iter</classname></paramtype></parameter><parameter name="it"><paramtype><classname>Iter</classname></paramtype></parameter><parameter name="last"><paramtype><classname>Sentinel</classname></paramtype></parameter><parameter name="message"><paramtype>std::string_view</paramtype></parameter><parameter name="preferred_max_line_length"><paramtype><classname>int64_t</classname></paramtype><default>80</default></parameter><parameter name="max_after_caret"><paramtype><classname>int64_t</classname></paramtype><default>40</default></parameter><description><para>Writes a formatted message (meaning prefixed with the file name, line, and column number) to <computeroutput>os</computeroutput>. This overload is Windows-only. </para></description></function>

<function name="write_formatted_expectation_failure_error_message"><type>std::ostream &amp;</type><template>
          <template-type-parameter name="Iter"/>
          <template-type-parameter name="Sentinel"/>
        </template><parameter name="os"><paramtype>std::ostream &amp;</paramtype></parameter><parameter name="filename"><paramtype>std::wstring_view</paramtype></parameter><parameter name="first"><paramtype><classname>Iter</classname></paramtype></parameter><parameter name="last"><paramtype><classname>Sentinel</classname></paramtype></parameter><parameter name="e"><paramtype><classname>parse_error</classname>&lt; <classname>Iter</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="preferred_max_line_length"><paramtype><classname>int64_t</classname></paramtype><default>80</default></parameter><parameter name="max_after_caret"><paramtype><classname>int64_t</classname></paramtype><default>40</default></parameter><description><para>Writes a formatted parse-expectation failure (meaning prefixed with the file name, line, and column number) to <computeroutput>os</computeroutput>. This overload is Windows-only. </para></description></function>


</namespace>
</namespace>
</header>
<header name="boost/parser/parser.hpp">
<namespace name="boost">
<namespace name="parser">
<struct name="attribute"><template>
      <template-type-parameter name="R"/>
      <template-type-parameter name="Parser"/>
    </template><description><para>A type trait that evaluates to the attribute type for parser <computeroutput>Parser</computeroutput> used to parse range <computeroutput>R</computeroutput>, as if by calling <computeroutput>parse(r, parser)</computeroutput>, using some <computeroutput>R r</computeroutput> and <computeroutput>Parser parser</computeroutput>. Note that this implies that pointers to null-terminated strings are supported types for <computeroutput>R</computeroutput>. The result is not wrapped in a <computeroutput>std::optional</computeroutput> like the result of a call to <computeroutput>parse()</computeroutput> would be. If <computeroutput>Parser</computeroutput> produces no attribute, the result is the no-attribute sentinel type <computeroutput>none</computeroutput>. </para></description><typedef name="initial_type"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef>
</struct><struct name="delimited_seq_parser"><template>
      <template-type-parameter name="Parser"/>
      <template-type-parameter name="DelimiterParser"/>
    </template><inherit access="public">boost::parser::repeat_parser&lt; Parser, DelimiterParser &gt;</inherit><description><para>Repeats the application of another parser <computeroutput>p</computeroutput> of type <computeroutput>Parser</computeroutput>, <computeroutput>[1, Inf)</computeroutput> times, applying a parser <computeroutput>d</computeroutput> of type <computeroutput>DelimiterParser</computeroutput> in between each pair of applications of <computeroutput>p</computeroutput>. The parse succeeds iff <computeroutput>p</computeroutput> succeeds at least once, and <computeroutput>d</computeroutput> succeeds each time it is applied. The attribute produced is a sequence of the type of attribute produced by <computeroutput>Parser</computeroutput>. </para></description><method-group name="public member functions">
</method-group>
<constructor><parameter name="parser"><paramtype><classname>Parser</classname></paramtype></parameter><parameter name="delimiter_parser"><paramtype><classname>DelimiterParser</classname></paramtype></parameter></constructor>
</struct><struct name="directive"><template>
      <template-nontype-parameter name="Parser"><type><classname>template</classname>&lt; <classname>class</classname> &gt; <classname>class</classname></type></template-nontype-parameter>
    </template><description><para>Represents a unparameterized higher-order parser (e.g. <computeroutput><classname alt="boost::parser::omit_parser">omit_parser</classname></computeroutput>) as a directive (e.g. <computeroutput>omit[other_parser]</computeroutput>). </para></description><method-group name="public member functions">
<method name="operator[]" cv="const noexcept"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-type-parameter name="Parser2"/>
        </template><parameter name="rhs"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser2</classname> &gt;</paramtype></parameter></method>
</method-group>
</struct><struct name="if_directive"><template>
      <template-type-parameter name="Predicate"/>
    </template><description><para>Represents a sequence parser, the first parser of which is an <computeroutput>epsilon_parser</computeroutput> with predicate, as a directive (e.g. <computeroutput>if_(pred)[p]</computeroutput>). </para></description><data-member name="pred_"><type><classname>Predicate</classname></type></data-member>
<method-group name="public member functions">
<method name="operator[]" cv="const noexcept"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-type-parameter name="Parser2"/>
        </template><parameter name="rhs"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser2</classname> &gt;</paramtype></parameter></method>
</method-group>
</struct><struct name="merge_directive"><description><para>A directive type that can only be used on sequence parsers, that forces the merge of all the sequence_parser's subparser's attributes into a single attribute. </para></description><method-group name="public member functions">
<method name="operator[]" cv="const noexcept"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-type-parameter name="ParserTuple"/>
          <template-type-parameter name="BacktrackingTuple"/>
          <template-type-parameter name="CombiningGroups"/>
        </template><parameter name="rhs"><paramtype><classname>parser_interface</classname>&lt; <classname>seq_parser</classname>&lt; <classname>ParserTuple</classname>, <classname>BacktrackingTuple</classname>, <classname>CombiningGroups</classname> &gt; &gt;</paramtype></parameter></method>
</method-group>
</struct><struct name="none"><method-group name="public member functions">
<method name="conversion-operator" cv="const"><type>T</type><template>
          <template-type-parameter name="T"/>
        </template></method>
<method name="operator+" cv="const"><type><classname>none</classname></type></method>
<method name="operator-" cv="const"><type><classname>none</classname></type></method>
<method name="operator*" cv="const"><type><classname>none</classname></type></method>
<method name="operator~" cv="const"><type><classname>none</classname></type></method>
<method name="operator&amp;" cv="const"><type><classname>none</classname></type></method>
<method name="operator!" cv="const"><type><classname>none</classname></type></method>
<method name="operator++"><type><classname>none</classname></type></method>
<method name="operator++"><type><classname>none</classname> &amp;</type><parameter name=""><paramtype><classname>int</classname></paramtype></parameter></method>
<method name="operator--"><type><classname>none</classname></type></method>
<method name="operator--"><type><classname>none</classname></type><parameter name=""><paramtype><classname>int</classname></paramtype></parameter></method>
<method name="operator&lt;&lt;" cv="const"><type><classname>none</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype><classname>T</classname> <classname>const</classname> &amp;</paramtype></parameter></method>
<method name="operator&gt;&gt;" cv="const"><type><classname>none</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype><classname>T</classname> <classname>const</classname> &amp;</paramtype></parameter></method>
<method name="operator*" cv="const"><type><classname>none</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype><classname>T</classname> <classname>const</classname> &amp;</paramtype></parameter></method>
<method name="operator/" cv="const"><type><classname>none</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype><classname>T</classname> <classname>const</classname> &amp;</paramtype></parameter></method>
<method name="operator%" cv="const"><type><classname>none</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype><classname>T</classname> <classname>const</classname> &amp;</paramtype></parameter></method>
<method name="operator+" cv="const"><type><classname>none</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype><classname>T</classname> <classname>const</classname> &amp;</paramtype></parameter></method>
<method name="operator-" cv="const"><type><classname>none</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype><classname>T</classname> <classname>const</classname> &amp;</paramtype></parameter></method>
<method name="operator&lt;" cv="const"><type><classname>none</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype><classname>T</classname> <classname>const</classname> &amp;</paramtype></parameter></method>
<method name="operator&gt;" cv="const"><type><classname>none</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype><classname>T</classname> <classname>const</classname> &amp;</paramtype></parameter></method>
<method name="operator&lt;=" cv="const"><type><classname>none</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype><classname>T</classname> <classname>const</classname> &amp;</paramtype></parameter></method>
<method name="operator&gt;=" cv="const"><type><classname>none</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype><classname>T</classname> <classname>const</classname> &amp;</paramtype></parameter></method>
<method name="operator==" cv="const"><type><classname>none</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype><classname>T</classname> <classname>const</classname> &amp;</paramtype></parameter></method>
<method name="operator!=" cv="const"><type><classname>none</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype><classname>T</classname> <classname>const</classname> &amp;</paramtype></parameter></method>
<method name="operator||" cv="const"><type><classname>none</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype><classname>T</classname> <classname>const</classname> &amp;</paramtype></parameter></method>
<method name="operator&amp;&amp;" cv="const"><type><classname>none</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype><classname>T</classname> <classname>const</classname> &amp;</paramtype></parameter></method>
<method name="operator&amp;" cv="const"><type><classname>none</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype><classname>T</classname> <classname>const</classname> &amp;</paramtype></parameter></method>
<method name="operator|" cv="const"><type><classname>none</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype><classname>T</classname> <classname>const</classname> &amp;</paramtype></parameter></method>
<method name="operator^" cv="const"><type><classname>none</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype><classname>T</classname> <classname>const</classname> &amp;</paramtype></parameter></method>
<method name="operator," cv="const"><type><classname>none</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype><classname>T</classname> <classname>const</classname> &amp;</paramtype></parameter></method>
<method name="operator-&gt;*" cv="const"><type><classname>none</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype><classname>T</classname> <classname>const</classname> &amp;</paramtype></parameter></method>
<method name="operator&lt;&lt;="><type><classname>none</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype><classname>T</classname> <classname>const</classname> &amp;</paramtype></parameter></method>
<method name="operator&gt;&gt;="><type><classname>none</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype><classname>T</classname> <classname>const</classname> &amp;</paramtype></parameter></method>
<method name="operator*="><type><classname>none</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype><classname>T</classname> <classname>const</classname> &amp;</paramtype></parameter></method>
<method name="operator/="><type><classname>none</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype><classname>T</classname> <classname>const</classname> &amp;</paramtype></parameter></method>
<method name="operator%="><type><classname>none</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype><classname>T</classname> <classname>const</classname> &amp;</paramtype></parameter></method>
<method name="operator+="><type><classname>none</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype><classname>T</classname> <classname>const</classname> &amp;</paramtype></parameter></method>
<method name="operator-="><type><classname>none</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype><classname>T</classname> <classname>const</classname> &amp;</paramtype></parameter></method>
<method name="operator&amp;="><type><classname>none</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype><classname>T</classname> <classname>const</classname> &amp;</paramtype></parameter></method>
<method name="operator|="><type><classname>none</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype><classname>T</classname> <classname>const</classname> &amp;</paramtype></parameter></method>
<method name="operator^="><type><classname>none</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype><classname>T</classname> <classname>const</classname> &amp;</paramtype></parameter></method>
<method name="operator[]" cv="const"><type><classname>none</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype><classname>T</classname> <classname>const</classname> &amp;</paramtype></parameter></method>
<method name="operator()" cv="const"><type><classname>none</classname></type><template>
          <template-nontype-parameter name="Args"><type>typename...</type></template-nontype-parameter>
        </template><parameter name="..."><paramtype><classname>Args</classname> <classname>const</classname> &amp;</paramtype></parameter></method>
<method name="fail" cv="const"><type><classname>void</classname></type></method>
</method-group>
<constructor cv="= default"/>
<constructor><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype><classname>T</classname> <classname>const</classname> &amp;</paramtype></parameter></constructor>
<copy-assignment><type><classname>none</classname> &amp;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype><classname>T</classname> <classname>const</classname> &amp;</paramtype></parameter></copy-assignment>
</struct><struct name="one_plus_parser"><template>
      <template-type-parameter name="Parser"/>
    </template><inherit access="public">boost::parser::repeat_parser&lt; Parser &gt;</inherit><description><para>Repeats the application of another parser <computeroutput>p</computeroutput> of type <computeroutput>Parser</computeroutput>, <computeroutput>[1, Inf)</computeroutput> times. The parse succeeds iff <computeroutput>p</computeroutput> succeeds at least once. The attribute produced is a sequence of the type of attribute produced by <computeroutput>Parser</computeroutput>. </para></description><method-group name="public member functions">
</method-group>
<constructor><parameter name="parser"><paramtype><classname>Parser</classname></paramtype></parameter></constructor>
</struct><struct name="opt_parser"><template>
      <template-type-parameter name="Parser"/>
    </template><description><para>Repeats the application of another parser of type <computeroutput>Parser</computeroutput>, <computeroutput>[0, 1]</computeroutput> times. The parse always succeeds. The attribute produced is a <computeroutput>std::optional&lt;T&gt;</computeroutput>, where <computeroutput>T</computeroutput> is the type of attribute produced by <computeroutput>Parser</computeroutput>. </para></description><data-member name="parser_"><type><classname>Parser</classname></type></data-member>
<method-group name="public member functions">
<method name="call" cv="const"><type><classname>auto</classname></type><template>
          <template-type-parameter name="Iter"/>
          <template-type-parameter name="Sentinel"/>
          <template-type-parameter name="Context"/>
          <template-type-parameter name="SkipParser"/>
        </template><parameter name="first"><paramtype><classname>Iter</classname> &amp;</paramtype></parameter><parameter name="last"><paramtype><classname>Sentinel</classname></paramtype></parameter><parameter name="context"><paramtype><classname>Context</classname> <classname>const</classname> &amp;</paramtype></parameter><parameter name="skip"><paramtype><classname>SkipParser</classname> <classname>const</classname> &amp;</paramtype></parameter><parameter name="flags"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><parameter name="success"><paramtype><classname>bool</classname> &amp;</paramtype></parameter></method>
<method name="call" cv="const"><type><classname>void</classname></type><template>
          <template-type-parameter name="Iter"/>
          <template-type-parameter name="Sentinel"/>
          <template-type-parameter name="Context"/>
          <template-type-parameter name="SkipParser"/>
          <template-type-parameter name="Attribute"/>
        </template><parameter name="first"><paramtype><classname>Iter</classname> &amp;</paramtype></parameter><parameter name="last"><paramtype><classname>Sentinel</classname></paramtype></parameter><parameter name="context"><paramtype><classname>Context</classname> <classname>const</classname> &amp;</paramtype></parameter><parameter name="skip"><paramtype><classname>SkipParser</classname> <classname>const</classname> &amp;</paramtype></parameter><parameter name="flags"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><parameter name="success"><paramtype><classname>bool</classname> &amp;</paramtype></parameter><parameter name="retval"><paramtype><classname>Attribute</classname> &amp;</paramtype></parameter></method>
</method-group>
</struct><struct name="or_parser"><template>
      <template-type-parameter name="ParserTuple"/>
    </template><description><para>Applies each parser in <computeroutput>ParserTuple</computeroutput>, in order, stopping after the application of the first one that succeeds. The parse succeeds iff one of the sub-parsers succeeds. The attribute produced is a <computeroutput>std::variant</computeroutput> over the types of attribute produced by the parsers in <computeroutput>ParserTuple</computeroutput>. </para></description><data-member name="parsers_"><type><classname>ParserTuple</classname></type></data-member>
<method-group name="public member functions">
<method name="call" cv="const"><type><classname>auto</classname></type><template>
          <template-type-parameter name="Iter"/>
          <template-type-parameter name="Sentinel"/>
          <template-type-parameter name="Context"/>
          <template-type-parameter name="SkipParser"/>
        </template><parameter name="first"><paramtype><classname>Iter</classname> &amp;</paramtype></parameter><parameter name="last"><paramtype><classname>Sentinel</classname></paramtype></parameter><parameter name="context"><paramtype><classname>Context</classname> <classname>const</classname> &amp;</paramtype></parameter><parameter name="skip"><paramtype><classname>SkipParser</classname> <classname>const</classname> &amp;</paramtype></parameter><parameter name="flags"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><parameter name="success"><paramtype><classname>bool</classname> &amp;</paramtype></parameter></method>
<method name="call" cv="const"><type><classname>void</classname></type><template>
          <template-type-parameter name="Iter"/>
          <template-type-parameter name="Sentinel"/>
          <template-type-parameter name="Context"/>
          <template-type-parameter name="SkipParser"/>
          <template-type-parameter name="Attribute"/>
        </template><parameter name="first"><paramtype><classname>Iter</classname> &amp;</paramtype></parameter><parameter name="last"><paramtype><classname>Sentinel</classname></paramtype></parameter><parameter name="context"><paramtype><classname>Context</classname> <classname>const</classname> &amp;</paramtype></parameter><parameter name="skip"><paramtype><classname>SkipParser</classname> <classname>const</classname> &amp;</paramtype></parameter><parameter name="flags"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><parameter name="success"><paramtype><classname>bool</classname> &amp;</paramtype></parameter><parameter name="retval"><paramtype><classname>Attribute</classname> &amp;</paramtype></parameter></method>
</method-group>
<constructor><parameter name="parsers"><paramtype><classname>ParserTuple</classname></paramtype></parameter></constructor>
</struct><struct name="parser_interface"><template>
      <template-type-parameter name="Parser"/>
      <template-type-parameter name="GlobalState"/>
      <template-type-parameter name="ErrorHandler"/>
    </template><description><para>A wrapper for parsers that provides the operations that must be supported by all parsers (e.g. <computeroutput>operator&gt;&gt;()</computeroutput>). <computeroutput>GlobalState</computeroutput> is an optional state object that can be accessed within semantic actions via a call to <computeroutput>_globals()</computeroutput>. This global state object is ignored for all but the topmost parser; the topmost global state object is available in the semantic actions of all nested parsers. <computeroutput>ErrorHandler</computeroutput> is the type of the error handler to be used on parse failure. This handler is ignored on all but the topmost parser; the topmost parser's error handler is used for all errors encountered during parsing. </para></description><typedef name="parser_type"><type><classname>Parser</classname></type></typedef>
<typedef name="global_state_type"><type><classname>GlobalState</classname></type></typedef>
<typedef name="error_handler_type"><type><classname>ErrorHandler</classname></type></typedef>
<typedef name="parser_interface_derivation_tag"><type><classname>int</classname></type></typedef>
<method-group name="public member functions">
<method name="operator!" cv="const noexcept"><type><classname>constexpr</classname> <classname>auto</classname></type><description><para>Returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname></computeroutput> containing a parser equivalent to an <computeroutput><classname alt="boost::parser::expect_parser">expect_parser</classname></computeroutput> containing <computeroutput>parser_</computeroutput>, with <computeroutput>FailOnMatch == true</computeroutput>. </para></description></method>
<method name="operator&amp;" cv="const noexcept"><type><classname>constexpr</classname> <classname>auto</classname></type><description><para>Returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname></computeroutput> containing a parser equivalent to an <computeroutput><classname alt="boost::parser::expect_parser">expect_parser</classname></computeroutput> containing <computeroutput>parser_</computeroutput>, with <computeroutput>FailOnMatch == false</computeroutput>. </para></description></method>
<method name="operator*" cv="const noexcept"><type><classname>constexpr</classname> <classname>auto</classname></type><description><para>Returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname></computeroutput> containing a parser equivalent to a <computeroutput><classname alt="boost::parser::zero_plus_parser">zero_plus_parser</classname></computeroutput> containing <computeroutput>parser_</computeroutput>. </para></description></method>
<method name="operator+" cv="const noexcept"><type><classname>constexpr</classname> <classname>auto</classname></type><description><para>Returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname></computeroutput> containing a parser equivalent to a <computeroutput><classname alt="boost::parser::one_plus_parser">one_plus_parser</classname></computeroutput> containing <computeroutput>parser_</computeroutput>. </para></description></method>
<method name="operator-" cv="const noexcept"><type><classname>constexpr</classname> <classname>auto</classname></type><description><para>Returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname></computeroutput> containing a parser equivalent to a <computeroutput><classname alt="boost::parser::opt_parser">opt_parser</classname></computeroutput> containing <computeroutput>parser_</computeroutput>. </para></description></method>
<method name="operator&gt;&gt;" cv="const noexcept"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-type-parameter name="ParserType2"/>
        </template><parameter name="rhs"><paramtype><classname>parser_interface</classname>&lt; <classname>ParserType2</classname> &gt;</paramtype></parameter><description><para>Returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname></computeroutput> containing a parser equivalent to a <computeroutput><classname alt="boost::parser::seq_parser">seq_parser</classname></computeroutput> containing <computeroutput>parser_</computeroutput> followed by <computeroutput>rhs.parser_</computeroutput>. </para></description></method>
<method name="operator&gt;&gt;" cv="const noexcept"><type><classname>constexpr</classname> <classname>auto</classname></type><parameter name="rhs"><paramtype><classname>char</classname></paramtype></parameter><description><para>Returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname></computeroutput> containing a parser equivalent to a <computeroutput><classname alt="boost::parser::seq_parser">seq_parser</classname></computeroutput> containing <computeroutput>parser_</computeroutput> followed by <computeroutput>lit(rhs)</computeroutput>. </para></description></method>
<method name="operator&gt;&gt;" cv="const noexcept"><type><classname>constexpr</classname> <classname>auto</classname></type><parameter name="rhs"><paramtype><classname>char32_t</classname></paramtype></parameter><description><para>Returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname></computeroutput> containing a parser equivalent to a <computeroutput><classname alt="boost::parser::seq_parser">seq_parser</classname></computeroutput> containing <computeroutput>parser_</computeroutput> followed by <computeroutput>lit(rhs)</computeroutput>. </para></description></method>
<method name="operator&gt;&gt;" cv="const noexcept"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-nontype-parameter name="R"><type><classname>parsable_range_like</classname></type></template-nontype-parameter>
        </template><parameter name="r"><paramtype><classname>R</classname> &amp;&amp;</paramtype></parameter><description><para>Returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname></computeroutput> containing a parser equivalent to a <computeroutput><classname alt="boost::parser::seq_parser">seq_parser</classname></computeroutput> containing <computeroutput>parser_</computeroutput> followed by <computeroutput>lit(rhs)</computeroutput>. </para></description></method>
<method name="operator&gt;" cv="const noexcept"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-type-parameter name="ParserType2"/>
        </template><parameter name="rhs"><paramtype><classname>parser_interface</classname>&lt; <classname>ParserType2</classname> &gt;</paramtype></parameter><description><para>Returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname></computeroutput> containing a parser equivalent to a <computeroutput><classname alt="boost::parser::seq_parser">seq_parser</classname></computeroutput> containing <computeroutput>parser_</computeroutput> followed by <computeroutput>rhs.parser_</computeroutput>. No back-tracking is allowed after <computeroutput>parser_</computeroutput> succeeds; if <computeroutput>rhs.parser_</computeroutput> fails after <computeroutput>parser_</computeroutput> succeeds, the top-level parse fails. </para></description></method>
<method name="operator&gt;" cv="const noexcept"><type><classname>constexpr</classname> <classname>auto</classname></type><parameter name="rhs"><paramtype><classname>char</classname></paramtype></parameter><description><para>Returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname></computeroutput> containing a parser equivalent to a <computeroutput><classname alt="boost::parser::seq_parser">seq_parser</classname></computeroutput> containing <computeroutput>parser_</computeroutput> followed by <computeroutput>lit(rhs)</computeroutput>. No back-tracking is allowed after <computeroutput>parser_</computeroutput> succeeds; if <computeroutput>lit(rhs)</computeroutput> fails after <computeroutput>parser_</computeroutput> succeeds, the top-level parse fails. </para></description></method>
<method name="operator&gt;" cv="const noexcept"><type><classname>constexpr</classname> <classname>auto</classname></type><parameter name="rhs"><paramtype><classname>char32_t</classname></paramtype></parameter><description><para>Returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname></computeroutput> containing a parser equivalent to a <computeroutput><classname alt="boost::parser::seq_parser">seq_parser</classname></computeroutput> containing <computeroutput>parser_</computeroutput> followed by <computeroutput>lit(rhs)</computeroutput>. No back-tracking is allowed after <computeroutput>parser_</computeroutput> succeeds; if <computeroutput>lit(rhs)</computeroutput> fails after <computeroutput>parser_</computeroutput> succeeds, the top-level parse fails. </para></description></method>
<method name="operator&gt;" cv="const noexcept"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-nontype-parameter name="R"><type><classname>parsable_range_like</classname></type></template-nontype-parameter>
        </template><parameter name="r"><paramtype><classname>R</classname> &amp;&amp;</paramtype></parameter><description><para>Returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname></computeroutput> containing a parser equivalent to a <computeroutput><classname alt="boost::parser::seq_parser">seq_parser</classname></computeroutput> containing <computeroutput>parser_</computeroutput> followed by <computeroutput>lit(rhs)</computeroutput>. No back-tracking is allowed after <computeroutput>parser_</computeroutput> succeeds; if <computeroutput>lit(rhs)</computeroutput> fails after <computeroutput>parser_</computeroutput> succeeds, the top-level parse fails. </para></description></method>
<method name="operator|" cv="const noexcept"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-type-parameter name="ParserType2"/>
        </template><parameter name="rhs"><paramtype><classname>parser_interface</classname>&lt; <classname>ParserType2</classname> &gt;</paramtype></parameter><description><para>Returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname></computeroutput> containing a parser equivalent to an <computeroutput><classname alt="boost::parser::or_parser">or_parser</classname></computeroutput> containing <computeroutput>parser_</computeroutput> followed by <computeroutput>rhs.parser_</computeroutput>. </para></description></method>
<method name="operator||" cv="const noexcept"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-type-parameter name="ParserType2"/>
        </template><parameter name="rhs"><paramtype><classname>parser_interface</classname>&lt; <classname>ParserType2</classname> &gt;</paramtype></parameter><description><para>Returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname></computeroutput> containing a parser equivalent to a <computeroutput><classname alt="boost::parser::perm_parser">perm_parser</classname></computeroutput> containing <computeroutput>parser_</computeroutput> followed by <computeroutput>rhs.parser_</computeroutput>. It is an error to use <computeroutput>eps</computeroutput> (conditional or not) with this operator. </para></description></method>
<method name="operator|" cv="const noexcept"><type><classname>constexpr</classname> <classname>auto</classname></type><parameter name="rhs"><paramtype><classname>char</classname></paramtype></parameter><description><para>Returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname></computeroutput> containing a parser equivalent to an <computeroutput><classname alt="boost::parser::or_parser">or_parser</classname></computeroutput> containing <computeroutput>parser_</computeroutput> followed by <computeroutput>lit(rhs)</computeroutput>. </para></description></method>
<method name="operator|" cv="const noexcept"><type><classname>constexpr</classname> <classname>auto</classname></type><parameter name="rhs"><paramtype><classname>char32_t</classname></paramtype></parameter><description><para>Returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname></computeroutput> containing a parser equivalent to an <computeroutput><classname alt="boost::parser::or_parser">or_parser</classname></computeroutput> containing <computeroutput>parser_</computeroutput> followed by <computeroutput>lit(rhs)</computeroutput>. </para></description></method>
<method name="operator|" cv="const noexcept"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-nontype-parameter name="R"><type><classname>parsable_range_like</classname></type></template-nontype-parameter>
        </template><parameter name="r"><paramtype><classname>R</classname> &amp;&amp;</paramtype></parameter><description><para>Returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname></computeroutput> containing a parser equivalent to an <computeroutput><classname alt="boost::parser::or_parser">or_parser</classname></computeroutput> containing <computeroutput>parser_</computeroutput> followed by <computeroutput>lit(rhs)</computeroutput>. </para></description></method>
<method name="operator-" cv="const noexcept"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-type-parameter name="ParserType2"/>
        </template><parameter name="rhs"><paramtype><classname>parser_interface</classname>&lt; <classname>ParserType2</classname> &gt;</paramtype></parameter><description><para>Returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname></computeroutput> containing a parser equivalent to <computeroutput>!rhs &gt;&gt; *this</computeroutput>. </para></description></method>
<method name="operator-" cv="const noexcept"><type><classname>constexpr</classname> <classname>auto</classname></type><parameter name="rhs"><paramtype><classname>char</classname></paramtype></parameter><description><para>Returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname></computeroutput> containing a parser equivalent to <computeroutput>!lit(rhs) &gt;&gt; *this</computeroutput>. </para></description></method>
<method name="operator-" cv="const noexcept"><type><classname>constexpr</classname> <classname>auto</classname></type><parameter name="rhs"><paramtype><classname>char32_t</classname></paramtype></parameter><description><para>Returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname></computeroutput> containing a parser equivalent to <computeroutput>!lit(rhs) &gt;&gt; *this</computeroutput>. </para></description></method>
<method name="operator-" cv="const noexcept"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-nontype-parameter name="R"><type><classname>parsable_range_like</classname></type></template-nontype-parameter>
        </template><parameter name="r"><paramtype><classname>R</classname> &amp;&amp;</paramtype></parameter><description><para>Returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname></computeroutput> containing a parser equivalent to <computeroutput>!lit(rhs) &gt;&gt; *this</computeroutput>. </para></description></method>
<method name="operator%" cv="const noexcept"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-type-parameter name="ParserType2"/>
        </template><parameter name="rhs"><paramtype><classname>parser_interface</classname>&lt; <classname>ParserType2</classname> &gt;</paramtype></parameter><description><para>Returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname></computeroutput> containing a parser equivalent to an <computeroutput><classname alt="boost::parser::delimited_seq_parser">delimited_seq_parser</classname></computeroutput> containing <computeroutput>parser_</computeroutput> and <computeroutput>rhs.parser_</computeroutput>. </para></description></method>
<method name="operator%" cv="const noexcept"><type><classname>constexpr</classname> <classname>auto</classname></type><parameter name="rhs"><paramtype><classname>char</classname></paramtype></parameter><description><para>Returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname></computeroutput> containing a parser equivalent to an <computeroutput><classname alt="boost::parser::delimited_seq_parser">delimited_seq_parser</classname></computeroutput> containing <computeroutput>parser_</computeroutput> and <computeroutput>lit(rhs)</computeroutput>. </para></description></method>
<method name="operator%" cv="const noexcept"><type><classname>constexpr</classname> <classname>auto</classname></type><parameter name="rhs"><paramtype><classname>char32_t</classname></paramtype></parameter><description><para>Returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname></computeroutput> containing a parser equivalent to an <computeroutput><classname alt="boost::parser::delimited_seq_parser">delimited_seq_parser</classname></computeroutput> containing <computeroutput>parser_</computeroutput> and <computeroutput>lit(rhs)</computeroutput>. </para></description></method>
<method name="operator%" cv="const noexcept"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-nontype-parameter name="R"><type><classname>parsable_range_like</classname></type></template-nontype-parameter>
        </template><parameter name="r"><paramtype><classname>R</classname> &amp;&amp;</paramtype></parameter><description><para>Returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname></computeroutput> containing a parser equivalent to an <computeroutput><classname alt="boost::parser::delimited_seq_parser">delimited_seq_parser</classname></computeroutput> containing <computeroutput>parser_</computeroutput> and <computeroutput>lit(rhs)</computeroutput>. </para></description></method>
<method name="operator[]" cv="const"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-type-parameter name="Action"/>
        </template><parameter name="action"><paramtype><classname>Action</classname></paramtype></parameter><description><para>Returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname></computeroutput> containing a parser equivalent to an <computeroutput><classname alt="boost::parser::action_parser">action_parser</classname></computeroutput> containing <computeroutput>parser_</computeroutput>, with semantic action <computeroutput>action</computeroutput>. </para></description></method>
<method name="operator()" cv="const noexcept"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-type-parameter name="Arg"/>
          <template-nontype-parameter name="Args"><type>typename...</type></template-nontype-parameter>
        </template><parameter name="arg"><paramtype><classname>Arg</classname> &amp;&amp;</paramtype></parameter><parameter name="args"><paramtype><classname>Args</classname> &amp;&amp;...</paramtype></parameter><description><para>Returns <computeroutput>parser_((Arg &amp;&amp;)arg, (Args &amp;&amp;)args...)</computeroutput>. This is useful for those parsers that have <computeroutput>operator()</computeroutput> overloads, e.g. <lsquo/>char_('x<rsquo/>)<lsquo/>. By convention, parsers<rsquo/> <computeroutput>operator()</computeroutput>s return <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname></computeroutput>s.</para><para>This function does not participate in overload resolution unless <computeroutput>parser_((Arg &amp;&amp;)arg, (Args &amp;&amp;)args...)</computeroutput> is well-formed. </para></description></method>
</method-group>
<constructor/>
<constructor><parameter name="p"><paramtype>parser_type</paramtype></parameter></constructor>
<constructor><parameter name="p"><paramtype>parser_type</paramtype></parameter><parameter name="gs"><paramtype>global_state_type</paramtype></parameter><parameter name="eh"><paramtype>error_handler_type</paramtype></parameter></constructor>
</struct><struct name="perm_parser"><template>
      <template-type-parameter name="ParserTuple"/>
    </template><description><para>Applies each parsers in <computeroutput>ParserTuple</computeroutput>, an any order, stopping after all of them have matched the input. The parse succeeds iff all the parsers match, regardless of the order in which they do. The attribute produced is a <computeroutput>parser::tuple</computeroutput> containing the attributes of the subparsers, in their order of the parsers' appearance in <computeroutput>ParserTuple</computeroutput>, not the order of the parsers' matches. It is an error to specialize <computeroutput><classname alt="boost::parser::perm_parser">perm_parser</classname></computeroutput> with a <computeroutput>ParserTuple</computeroutput> template parameter that includes an <computeroutput><classname alt="boost::parser::eps_parser">eps_parser</classname></computeroutput>. </para></description><data-member name="parsers_"><type><classname>ParserTuple</classname></type></data-member>
<method-group name="public member functions">
<method name="call" cv="const"><type><classname>auto</classname></type><template>
          <template-type-parameter name="Iter"/>
          <template-type-parameter name="Sentinel"/>
          <template-type-parameter name="Context"/>
          <template-type-parameter name="SkipParser"/>
        </template><parameter name="first_"><paramtype><classname>Iter</classname> &amp;</paramtype></parameter><parameter name="last"><paramtype><classname>Sentinel</classname></paramtype></parameter><parameter name="context"><paramtype><classname>Context</classname> <classname>const</classname> &amp;</paramtype></parameter><parameter name="skip"><paramtype><classname>SkipParser</classname> <classname>const</classname> &amp;</paramtype></parameter><parameter name="flags"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><parameter name="success"><paramtype><classname>bool</classname> &amp;</paramtype></parameter></method>
<method name="call" cv="const"><type><classname>void</classname></type><template>
          <template-type-parameter name="Iter"/>
          <template-type-parameter name="Sentinel"/>
          <template-type-parameter name="Context"/>
          <template-type-parameter name="SkipParser"/>
          <template-type-parameter name="Attribute"/>
        </template><parameter name="first_"><paramtype><classname>Iter</classname> &amp;</paramtype></parameter><parameter name="last"><paramtype><classname>Sentinel</classname></paramtype></parameter><parameter name="context"><paramtype><classname>Context</classname> <classname>const</classname> &amp;</paramtype></parameter><parameter name="skip"><paramtype><classname>SkipParser</classname> <classname>const</classname> &amp;</paramtype></parameter><parameter name="flags"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><parameter name="success"><paramtype><classname>bool</classname> &amp;</paramtype></parameter><parameter name="retval"><paramtype><classname>Attribute</classname> &amp;</paramtype></parameter></method>
<method name="call_impl" cv="const"><type><classname>void</classname></type><template>
          <template-type-parameter name="Iter"/>
          <template-type-parameter name="Sentinel"/>
          <template-type-parameter name="Context"/>
          <template-type-parameter name="SkipParser"/>
          <template-nontype-parameter name="Ts"><type>typename...</type></template-nontype-parameter>
          <template-nontype-parameter name="Is"><type>int...</type></template-nontype-parameter>
        </template><parameter name="first"><paramtype><classname>Iter</classname> &amp;</paramtype></parameter><parameter name="last"><paramtype><classname>Sentinel</classname></paramtype></parameter><parameter name="context"><paramtype><classname>Context</classname> <classname>const</classname> &amp;</paramtype></parameter><parameter name="skip"><paramtype><classname>SkipParser</classname> <classname>const</classname> &amp;</paramtype></parameter><parameter name="flags"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><parameter name="success"><paramtype><classname>bool</classname> &amp;</paramtype></parameter><parameter name="retval"><paramtype>tuple&lt; Ts... &gt; &amp;</paramtype></parameter><parameter name=""><paramtype>std::integer_sequence&lt; <classname>int</classname>, Is... &gt;</paramtype></parameter></method>
</method-group>
<constructor><parameter name="parsers"><paramtype><classname>ParserTuple</classname></paramtype></parameter></constructor>
</struct><struct name="quoted_string_parser"><template>
      <template-type-parameter name="Quotes"/>
      <template-type-parameter name="Escapes"/>
    </template><description><para>Matches a string delimited by quotation marks; produces a <computeroutput>std::string</computeroutput> attribute. </para></description><data-member name="chs_"><type><classname>Quotes</classname></type></data-member>
<data-member name="escapes_"><type><classname>Escapes</classname></type></data-member>
<data-member name="ch_"><type><classname>char32_t</classname></type></data-member>
<method-group name="public member functions">
<method name="parser_interface"><type><classname>constexpr</classname> <classname>quoted_string_parser</classname>() <classname>return</classname></type><parameter name=""><paramtype><classname>quoted_string_parser</classname>(std::move(<classname>x</classname>))</paramtype></parameter></method>
<method name="operator()" cv="const noexcept"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-nontype-parameter name="R"><type><classname>parsable_range_like</classname></type></template-nontype-parameter>
        </template><parameter name="r"><paramtype><classname>R</classname> &amp;&amp;</paramtype></parameter><description><para>Returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname></computeroutput> containing a <computeroutput><classname alt="boost::parser::quoted_string_parser">quoted_string_parser</classname></computeroutput> that accepts any of the values in <computeroutput>r</computeroutput> as its quotation marks. If the input being matched during the parse is a a sequence of <computeroutput>char32_t</computeroutput>, the elements of <computeroutput>r</computeroutput> are transcoded from their presumed encoding to UTF-32 during the comparison. Otherwise, the character begin matched is directly compared to the elements of <computeroutput>r</computeroutput>. </para></description></method>
<method name="operator()" cv="const noexcept"><type><classname>auto</classname></type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="x"><paramtype><classname>T</classname></paramtype></parameter><parameter name="escapes"><paramtype><classname>symbols</classname>&lt; <classname>U</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><description><para>Returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname></computeroutput> containing a <computeroutput><classname alt="boost::parser::quoted_string_parser">quoted_string_parser</classname></computeroutput> that uses <computeroutput>x</computeroutput> as its quotation marks. <computeroutput>symbols</computeroutput> provides a list of strings that may appear after a backslash to form an escape sequence, and what character(s) each escape sequence represents. Note that <computeroutput>"\\"&lt;/tt&gt; and &lt;tt&gt;"\ch"</computeroutput> are always valid escape sequences. </para></description></method>
<method name="operator()" cv="const noexcept"><type><classname>auto</classname></type><template>
          <template-nontype-parameter name="R"><type><classname>parsable_range_like</classname></type></template-nontype-parameter>
          <template-type-parameter name="T"/>
        </template><parameter name="r"><paramtype><classname>R</classname> &amp;&amp;</paramtype></parameter><parameter name="escapes"><paramtype><classname>symbols</classname>&lt; <classname>T</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><description><para>Returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname></computeroutput> containing a <computeroutput><classname alt="boost::parser::quoted_string_parser">quoted_string_parser</classname></computeroutput> that accepts any of the values in <computeroutput>r</computeroutput> as its quotation marks. If the input being matched during the parse is a a sequence of <computeroutput>char32_t</computeroutput>, the elements of <computeroutput>r</computeroutput> are transcoded from their presumed encoding to UTF-32 during the comparison. Otherwise, the character begin matched is directly compared to the elements of <computeroutput>r</computeroutput>. <computeroutput>symbols</computeroutput> provides a list of strings that may appear after a backslash to form an escape sequence, and what character(s) each escape sequence represents. Note that <computeroutput>"\\"&lt;/tt&gt; and &lt;tt&gt;"\ch"</computeroutput> are always valid escape sequences. </para></description></method>
</method-group>
</struct><struct name="repeat_directive"><template>
      <template-type-parameter name="MinType"/>
      <template-type-parameter name="MaxType"/>
    </template><description><para>Represents a <computeroutput><classname alt="boost::parser::repeat_parser">repeat_parser</classname></computeroutput> as a directive (e.g. <computeroutput>repeat[other_parser]</computeroutput>). </para></description><data-member name="min_"><type><classname>MinType</classname></type></data-member>
<data-member name="max_"><type><classname>MaxType</classname></type></data-member>
<method-group name="public member functions">
<method name="operator[]" cv="const noexcept"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-type-parameter name="Parser2"/>
        </template><parameter name="rhs"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser2</classname> &gt;</paramtype></parameter></method>
</method-group>
</struct><struct name="separate_directive"><description><para>A directive type that can only be used on sequence parsers, that prevents each of the sequence_parser's subparser's attributes from merging with any other subparser's attribute. </para></description><method-group name="public member functions">
<method name="operator[]" cv="const noexcept"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-type-parameter name="ParserTuple"/>
          <template-type-parameter name="BacktrackingTuple"/>
          <template-type-parameter name="CombiningGroups"/>
        </template><parameter name="rhs"><paramtype><classname>parser_interface</classname>&lt; <classname>seq_parser</classname>&lt; <classname>ParserTuple</classname>, <classname>BacktrackingTuple</classname>, <classname>CombiningGroups</classname> &gt; &gt;</paramtype></parameter></method>
</method-group>
</struct><struct name="skip_directive"><template>
      <template-type-parameter name="SkipParser"><default><classname alt="boost::parser::detail::nope">detail::nope</classname></default></template-type-parameter>
    </template><description><para>Represents a skip parser as a directive. When used without a skip parser, e.g. <computeroutput>skip[parser_in_which_to_do_skipping]</computeroutput>, the skipper for the entire parse is used. When given another parser, e.g. <computeroutput>skip(skip_parser)[parser_in_which_to_do_skipping]</computeroutput>, that other parser is used as the skipper within the directive. </para></description><data-member name="skip_parser_"><type><classname>SkipParser</classname></type></data-member>
<method-group name="public member functions">
<method name="operator[]" cv="const noexcept"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-type-parameter name="Parser"/>
        </template><parameter name="rhs"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname> &gt;</paramtype></parameter></method>
<method name="operator()" cv="const noexcept"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-type-parameter name="SkipParser2"/>
        </template><parameter name="skip_parser"><paramtype><classname>parser_interface</classname>&lt; <classname>SkipParser2</classname> &gt;</paramtype></parameter><description><para>Returns a <computeroutput><classname alt="boost::parser::skip_directive">skip_directive</classname></computeroutput> with <computeroutput><classname alt="boost::parser::skip_parser">skip_parser</classname></computeroutput> as its skipper. </para></description></method>
</method-group>
</struct><struct name="symbols"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::parser::parser_interface&lt; symbol_parser&lt; T &gt; &gt;</inherit><description><para>A <computeroutput>symbols&lt;T&gt;</computeroutput> represents the initial state of a symbol table parser that produces attributes of type <computeroutput>T</computeroutput>. The entries in the symbol table can be changed during parsing, but those mutations to not affect the <computeroutput>symbols&lt;T&gt;</computeroutput> object itself; all mutations happen to a copy of the symbol table in the parse context. For table entries that should be used during every parse, add entries via <computeroutput>add()</computeroutput> or <computeroutput>operator()</computeroutput>. For mid-parse mutations, use <computeroutput>insert()</computeroutput> and <computeroutput>erase()</computeroutput>. </para></description><method-group name="public member functions">
<method name="insert_for_next_parse"><type><classname>void</classname></type><parameter name="str"><paramtype>std::string_view</paramtype></parameter><parameter name="x"><paramtype><classname>T</classname></paramtype></parameter><description><para>Inserts an entry consisting of a UTF-8 string <computeroutput>str</computeroutput> to match, and an associated attribute <computeroutput>x</computeroutput>, to <computeroutput>*this</computeroutput>. The entry is added for use in all subsequent top-level parses. Subsequent lookups during the current top-level parse will not necessarily match <computeroutput>str</computeroutput>. </para></description></method>
<method name="erase_for_next_parse"><type><classname>void</classname></type><parameter name="str"><paramtype>std::string_view</paramtype></parameter><description><para>Erases the entry whose UTF-8 match string is <computeroutput>str</computeroutput>, from <computeroutput>*this</computeroutput>. The entry will no longer be available for use in all subsequent top-level parses. <computeroutput>str</computeroutput> will not be removed from the symbols matched in the current top-level parse. </para></description></method>
<method name="clear_for_next_parse"><type><classname>void</classname></type><description><para>Erases all the entries from the copy of the symbol table inside the parse context <computeroutput>context</computeroutput>. </para></description></method>
<method name="insert_for_next_parse"><type><classname>void</classname></type><template>
          <template-type-parameter name="Context"/>
        </template><parameter name="context"><paramtype><classname>Context</classname> <classname>const</classname> &amp;</paramtype></parameter><parameter name="str"><paramtype>std::string_view</paramtype></parameter><parameter name="x"><paramtype><classname>T</classname></paramtype></parameter><description><para>Inserts an entry consisting of a UTF-8 string <computeroutput>str</computeroutput> to match, and an associated attribute <computeroutput>x</computeroutput>, to <computeroutput>*this</computeroutput>. The entry is added for use in all subsequent top-level parses. Subsequent lookups during the current top-level parse will not necessarily match <computeroutput>str</computeroutput>. </para></description></method>
<method name="erase_for_next_parse"><type><classname>void</classname></type><template>
          <template-type-parameter name="Context"/>
        </template><parameter name="context"><paramtype><classname>Context</classname> <classname>const</classname> &amp;</paramtype></parameter><parameter name="str"><paramtype>std::string_view</paramtype></parameter><description><para>Erases the entry whose UTF-8 match string is <computeroutput>str</computeroutput>, from <computeroutput>*this</computeroutput>. The entry will no longer be available for use in all subsequent top-level parses. <computeroutput>str</computeroutput> will not be removed from the symbols matched in the current top-level parse. </para></description></method>
<method name="clear_for_next_parse"><type><classname>void</classname></type><template>
          <template-type-parameter name="Context"/>
        </template><parameter name="context"><paramtype><classname>Context</classname> <classname>const</classname> &amp;</paramtype></parameter><description><para>Erases all the entries from the copy of the symbol table inside the parse context <computeroutput>context</computeroutput>. </para></description></method>
<method name="find" cv="const"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Context"/>
        </template><parameter name="context"><paramtype><classname>Context</classname> <classname>const</classname> &amp;</paramtype></parameter><parameter name="str"><paramtype>std::string_view</paramtype></parameter><description><para>Uses UTF-8 string <computeroutput>str</computeroutput> to look up an attribute in the table during parsing, returning it as an optional reference. The lookup is done on the copy of the symbol table inside the parse context <computeroutput>context</computeroutput>, not <computeroutput>*this</computeroutput>. </para></description></method>
<method name="insert" cv="const"><type><classname>void</classname></type><template>
          <template-type-parameter name="Context"/>
        </template><parameter name="context"><paramtype><classname>Context</classname> <classname>const</classname> &amp;</paramtype></parameter><parameter name="str"><paramtype>std::string_view</paramtype></parameter><parameter name="x"><paramtype><classname>T</classname></paramtype></parameter><description><para>Inserts an entry consisting of a UTF-8 string to match <computeroutput>str</computeroutput>, and an associtated attribute <computeroutput>x</computeroutput>, to the copy of the symbol table inside the parse context <computeroutput>context</computeroutput>. </para></description></method>
<method name="erase" cv="const"><type><classname>void</classname></type><template>
          <template-type-parameter name="Context"/>
        </template><parameter name="context"><paramtype><classname>Context</classname> <classname>const</classname> &amp;</paramtype></parameter><parameter name="str"><paramtype>std::string_view</paramtype></parameter><description><para>Erases the entry whose UTF-8 match string is <computeroutput>str</computeroutput> from the copy of the symbol table inside the parse context <computeroutput>context</computeroutput>. </para></description></method>
<method name="clear" cv="const"><type><classname>void</classname></type><template>
          <template-type-parameter name="Context"/>
        </template><parameter name="context"><paramtype><classname>Context</classname> <classname>const</classname> &amp;</paramtype></parameter><description><para>Erases all the entries from the copy of the symbol table inside the parse context <computeroutput>context</computeroutput>. </para></description></method>
</method-group>
<constructor/>
<constructor><parameter name="diagnostic_text"><paramtype><classname>char</classname> <classname>const</classname> *</paramtype></parameter></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; std::pair&lt; std::string_view, <classname>T</classname> &gt; &gt;</paramtype></parameter></constructor>
<constructor><parameter name="diagnostic_text"><paramtype><classname>char</classname> <classname>const</classname> *</paramtype></parameter><parameter name="il"><paramtype>std::initializer_list&lt; std::pair&lt; std::string_view, <classname>T</classname> &gt; &gt;</paramtype></parameter></constructor>
</struct><struct name="transform_directive"><template>
      <template-type-parameter name="F"/>
    </template><description><para>A directive that transforms the attribute generated by a parser. <computeroutput>operator[]</computeroutput> returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname>&lt;<classname alt="boost::parser::transform_parser">transform_parser</classname>&lt;Parser, F&gt;&gt;</computeroutput>. </para></description><data-member name="f_"><type>F</type></data-member>
<method-group name="public member functions">
<method name="operator[]" cv="const noexcept"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-type-parameter name="Parser"/>
        </template><parameter name="rhs"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname> &gt;</paramtype></parameter></method>
</method-group>
</struct><struct name="zero_plus_parser"><template>
      <template-type-parameter name="Parser"/>
    </template><inherit access="public">boost::parser::repeat_parser&lt; Parser &gt;</inherit><description><para>Repeats the application of another parser <computeroutput>p</computeroutput> of type <computeroutput>Parser</computeroutput>, <computeroutput>[0, Inf)</computeroutput> times. The parse always succeeds. The attribute produced is a sequence of the type of attribute produced by <computeroutput>Parser</computeroutput>. </para></description><method-group name="public member functions">
</method-group>
<constructor><parameter name="parser"><paramtype><classname>Parser</classname></paramtype></parameter></constructor>
</struct><namespace name="literals">

<function name="operator&quot;&quot;_l"><type><classname>constexpr</classname> <classname>auto</classname></type><parameter name="c"><paramtype><classname>char</classname></paramtype></parameter><description><para>Returns a literal parser equivalent to <computeroutput>lit(c)</computeroutput>. </para></description></function>
<function name="operator&quot;&quot;_l"><type><classname>constexpr</classname> <classname>auto</classname></type><parameter name="c"><paramtype><classname>char8_t</classname></paramtype></parameter><description><para>Returns a literal parser equivalent to <computeroutput>lit(c)</computeroutput>. </para></description></function>
<function name="operator&quot;&quot;_l"><type><classname>constexpr</classname> <classname>auto</classname></type><parameter name="c"><paramtype><classname>char32_t</classname></paramtype></parameter><description><para>Returns a literal parser equivalent to <computeroutput>lit(c)</computeroutput>. </para></description></function>
<function name="operator&quot;&quot;_l"><type><classname>constexpr</classname> <classname>auto</classname></type><parameter name="str"><paramtype><classname>char</classname> <classname>const</classname> *</paramtype></parameter><parameter name=""><paramtype>std::size_t</paramtype></parameter><description><para>Returns a literal parser equivalent to <computeroutput>lit(str)</computeroutput>. </para></description></function>
<function name="operator&quot;&quot;_l"><type><classname>constexpr</classname> <classname>auto</classname></type><parameter name="str"><paramtype><classname>char8_t</classname> <classname>const</classname> *</paramtype></parameter><parameter name=""><paramtype>std::size_t</paramtype></parameter><description><para>Returns a literal parser equivalent to <computeroutput>lit(str)</computeroutput>. </para></description></function>
<function name="operator&quot;&quot;_l"><type><classname>constexpr</classname> <classname>auto</classname></type><parameter name="str"><paramtype><classname>char32_t</classname> <classname>const</classname> *</paramtype></parameter><parameter name=""><paramtype>std::size_t</paramtype></parameter><description><para>Returns a literal parser equivalent to <computeroutput>lit(str)</computeroutput>. </para></description></function>
<function name="operator&quot;&quot;_p"><type><classname>constexpr</classname> <classname>auto</classname></type><parameter name="c"><paramtype><classname>char</classname></paramtype></parameter><description><para>Returns a character parser equivalent to <computeroutput>char_(c)</computeroutput>. </para></description></function>
<function name="operator&quot;&quot;_p"><type><classname>constexpr</classname> <classname>auto</classname></type><parameter name="c"><paramtype><classname>char8_t</classname></paramtype></parameter><description><para>Returns a character parser equivalent to <computeroutput>char_(c)</computeroutput>. </para></description></function>
<function name="operator&quot;&quot;_p"><type><classname>constexpr</classname> <classname>auto</classname></type><parameter name="c"><paramtype><classname>char32_t</classname></paramtype></parameter><description><para>Returns a character parser equivalent to <computeroutput>char_(c)</computeroutput>. </para></description></function>
<function name="operator&quot;&quot;_p"><type><classname>constexpr</classname> <classname>auto</classname></type><parameter name="str"><paramtype><classname>char</classname> <classname>const</classname> *</paramtype></parameter><parameter name=""><paramtype>std::size_t</paramtype></parameter><description><para>Returns a string parser equivalent to <computeroutput>string(str)</computeroutput>. </para></description></function>
<function name="operator&quot;&quot;_p"><type><classname>constexpr</classname> <classname>auto</classname></type><parameter name="str"><paramtype><classname>char8_t</classname> <classname>const</classname> *</paramtype></parameter><parameter name=""><paramtype>std::size_t</paramtype></parameter><description><para>Returns a string parser equivalent to <computeroutput>string(str)</computeroutput>. </para></description></function>
<function name="operator&quot;&quot;_p"><type><classname>constexpr</classname> <classname>auto</classname></type><parameter name="str"><paramtype><classname>char32_t</classname> <classname>const</classname> *</paramtype></parameter><parameter name=""><paramtype>std::size_t</paramtype></parameter><description><para>Returns a string parser equivalent to <computeroutput>string(str)</computeroutput>. </para></description></function>
</namespace>
<enum name="trace"><enumvalue name="off"/><enumvalue name="on"/><description><para>An enumeration used for parameters to enable and disable trace in the <computeroutput>*parse()</computeroutput> functions. </para></description></enum>
<data-member name="_p"><type><emphasis>unspecified</emphasis></type><description><para>An invocable that returns the <computeroutput>I</computeroutput>th parameter to the bottommost rule. This is useful for forwarding parameters to sub-rules. </para></description></data-member>
<data-member name="Inf"><type><classname>int64_t</classname> <classname>const</classname></type><description><para>A very large sentinel value used to represent pseudo-infinity. </para></description></data-member>
<data-member name="omit"><type><classname>constexpr</classname> <classname>directive</classname>&lt; <classname>omit_parser</classname> &gt;</type><description><para>The <computeroutput>omit</computeroutput> directive, whose <computeroutput>operator[]</computeroutput> returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname>&lt;<classname alt="boost::parser::omit_parser">omit_parser</classname>&lt;P&gt;&gt;</computeroutput> from a given parser of type <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname>&lt;P&gt;</computeroutput>. </para></description></data-member>
<data-member name="raw"><type><classname>constexpr</classname> <classname>directive</classname>&lt; <classname>raw_parser</classname> &gt;</type><description><para>The <computeroutput>raw</computeroutput> directive, whose <computeroutput>operator[]</computeroutput> returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname>&lt;<classname alt="boost::parser::raw_parser">raw_parser</classname>&lt;P&gt;&gt;</computeroutput> from a given parser of type <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname>&lt;P&gt;</computeroutput>. </para></description></data-member>
<data-member name="string_view"><type><classname>constexpr</classname> <classname>directive</classname>&lt; <classname>string_view_parser</classname> &gt;</type><description><para>The <computeroutput>string_view</computeroutput> directive, whose <computeroutput>operator[]</computeroutput> returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname>&lt;<classname alt="boost::parser::string_view_parser">string_view_parser</classname>&lt;P&gt;&gt;</computeroutput> from a given parser of type <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname>&lt;P&gt;</computeroutput>. This is only available in C++20 and later. </para></description></data-member>
<data-member name="lexeme"><type><classname>constexpr</classname> <classname>directive</classname>&lt; <classname>lexeme_parser</classname> &gt;</type><description><para>The <computeroutput>lexeme</computeroutput> directive, whose <computeroutput>operator[]</computeroutput> returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname>&lt;<classname alt="boost::parser::lexeme_parser">lexeme_parser</classname>&lt;P&gt;&gt;</computeroutput> from a given parser of type <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname>&lt;P&gt;</computeroutput>. </para></description></data-member>
<data-member name="no_case"><type><classname>constexpr</classname> <classname>directive</classname>&lt; <classname>no_case_parser</classname> &gt;</type><description><para>The <computeroutput>no_case</computeroutput> directive, whose <computeroutput>operator[]</computeroutput> returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname>&lt;<classname alt="boost::parser::no_case_parser">no_case_parser</classname>&lt;P&gt;&gt;</computeroutput> from a given parser of type <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname>&lt;P&gt;</computeroutput>. </para></description></data-member>
<data-member name="skip"><type><classname>constexpr</classname> <classname>skip_directive</classname></type><description><para>The <computeroutput><classname alt="boost::parser::skip_directive">skip_directive</classname></computeroutput>, whose <computeroutput>operator[]</computeroutput> returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname>&lt;<classname alt="boost::parser::skip_parser">skip_parser</classname>&lt;P&gt;&gt;</computeroutput> from a given parser of type <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname>&lt;P&gt;</computeroutput>. </para></description></data-member>
<data-member name="merge"><type><classname>constexpr</classname> <classname>merge_directive</classname></type><description><para>The <computeroutput><classname alt="boost::parser::merge_directive">merge_directive</classname></computeroutput>, whose <computeroutput>operator[]</computeroutput> returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname>&lt;P2&gt;</computeroutput>, from a given parser of type <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname>&lt;P&gt;</computeroutput>, where <computeroutput>P</computeroutput> is a <computeroutput><classname alt="boost::parser::seq_parser">seq_parser</classname></computeroutput>. <computeroutput>P2</computeroutput> is the same as <computeroutput>P</computeroutput>, except that its <computeroutput>CombiningGroups</computeroutput> template parameter is replaced with a tag type that causes the subparser's attributes to be merged into a single attribute. </para></description></data-member>
<data-member name="separate"><type><classname>constexpr</classname> <classname>separate_directive</classname></type><description><para>The <computeroutput><classname alt="boost::parser::separate_directive">separate_directive</classname></computeroutput>, whose <computeroutput>operator[]</computeroutput> returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname>&lt;P2&gt;</computeroutput>, from a given parser of type <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname>&lt;P&gt;</computeroutput>, where <computeroutput>P</computeroutput> is a <computeroutput><classname alt="boost::parser::seq_parser">seq_parser</classname></computeroutput>. <computeroutput>P2</computeroutput> is the same as <computeroutput>P</computeroutput>, except that its <computeroutput>CombiningGroups</computeroutput> template parameter is replaced with a tag type that prevents each subparser's attribute from merging with any other subparser's attribute. </para></description></data-member>
<data-member name="eps"><type><emphasis>unspecified</emphasis></type><description><para>The epsilon parser. This matches anything, and consumes no input. If used with an optional predicate, like <computeroutput>eps(pred)</computeroutput>, it matches iff <computeroutput>pred(ctx)</computeroutput> evaluates to true, where <computeroutput>ctx</computeroutput> is the parser context. </para></description></data-member>
<data-member name="eoi"><type><classname>constexpr</classname> <classname>parser_interface</classname>&lt; <classname>eoi_parser</classname> &gt;</type><description><para>The end-of-input parser. It matches only the end of input. </para></description></data-member>
<data-member name="char_"><type><emphasis>unspecified</emphasis></type><description><para>The single-character parser. The produced attribute is the type of the matched code point (<computeroutput>char</computeroutput> or <computeroutput>char32_t</computeroutput>). Used as-is, <computeroutput>char_</computeroutput> matches any code point. <computeroutput>char_</computeroutput> can also can be used to create code point parsers that match one or more specific code point values, by calling it with: a single value comparable to a code point; a closed range of code point values <computeroutput>[lo, hi]</computeroutput>, or a set of code point values passed as a range. When calling with a range, only the iterators that bound the range are stored. Make sure the range you pass outlives the use of the resulting parser. Note that a string literal is a range, and that it outlives any parser it is used to construct. </para></description></data-member>
<data-member name="cp"><type><emphasis>unspecified</emphasis></type><description><para>The code point parser. It produces a <computeroutput>char32_t</computeroutput> attribute. Used as-is, <computeroutput>cp</computeroutput> matches any code point. <computeroutput>cp</computeroutput> can also can be used to create code point parsers that match one or more specific code point values, by calling it with: a single value comparable to a code point; a closed range of code point values <computeroutput>[lo, hi]</computeroutput>, or a set of code point values passed as a range. When calling with a range, only the iterators that bound the range are stored. Make sure the range you pass outlives the use of the resulting parser. Note that a string literal is a range, and that it outlives any parser it is used to construct. </para></description></data-member>
<data-member name="cu"><type><emphasis>unspecified</emphasis></type><description><para>The code unit parser. It produces a <computeroutput>char</computeroutput> attribute. Used as-is, <computeroutput>cu</computeroutput> matches any code point. <computeroutput>cu</computeroutput> can also can be used to create code point parsers that match one or more specific code point values, by calling it with: a single value comparable to a code point; a closed range of code point values <computeroutput>[lo, hi]</computeroutput>, or a set of code point values passed as a range. When calling with a range, only the iterators that bound the range are stored. Make sure the range you pass outlives the use of the resulting parser. Note that a string literal is a range, and that it outlives any parser it is used to construct. </para></description></data-member>
<data-member name="quoted_string"><type><classname>constexpr</classname> <classname>parser_interface</classname>&lt; <classname>quoted_string_parser</classname>&lt;&gt; &gt;</type><description><para>Parses a string delimited by quotation marks. This parser can be used to create parsers that accept one or more specific quotation mark characters. By default, the quotation marks are <lsquo/><rsquo/>"'<computeroutput>; an alternate quotation mark can be specified by calling this parser with a single character, or a range of characters. If a range is specified, the opening quote must be one of the characters specified, and the closing quote must match the opening quote. Quotation marks may appear within the string if escaped with a backslash, and a pair of backslashes is treated as a single escaped backslash; all other backslashes cause the parse to fail, unless a symbol table is in use. A symbol table can be provided as a second parameter after the single character or range described above. The symbol table is used to recognize escape sequences. Each escape sequence is a backslash followed by a value in the symbol table. When using a symbol table, any backslash that is not followed by another backslash, the opening quote character, or a symbol from the symbol table will cause the parse to fail. Skipping is disabled during parsing of the entire quoted string, including the quotation marks. There is an expectation point before the closing quotation mark. Produces a</computeroutput>std::string` attribute. </para></description></data-member>
<data-member name="eol"><type><classname>constexpr</classname> <classname>parser_interface</classname>&lt; <classname>ws_parser</classname>&lt; <classname>true</classname>, <classname>false</classname> &gt; &gt;</type><description><para>The end-of-line parser. This matches "\r\n", or any one of the line break code points from the Unicode Line Break Algorithm, described in <ulink url="https://unicode.org/reports/tr14">https://unicode.org/reports/tr14</ulink>. Produces no attribute. </para></description></data-member>
<data-member name="ws"><type><classname>constexpr</classname> <classname>parser_interface</classname>&lt; <classname>ws_parser</classname>&lt; <classname>false</classname>, <classname>false</classname> &gt; &gt;</type><description><para>The whitespace parser. This matches "\r\n", or any one of the Unicode code points with the White_Space property, as defined in <ulink url="https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt">https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt</ulink>. Produces no attribute. </para></description></data-member>
<data-member name="blank"><type><classname>constexpr</classname> <classname>parser_interface</classname>&lt; <classname>ws_parser</classname>&lt; <classname>false</classname>, <classname>true</classname> &gt; &gt;</type><description><para>The whitespace parser that does not match end-of-line. This matches any one of the Unicode code points with the White_Space property, as defined in <ulink url="https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt">https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt</ulink>, except for the ones matched by <computeroutput>eol</computeroutput>. Produces no attribute. </para></description></data-member>
<data-member name="digit"><type><classname>constexpr</classname> <classname>parser_interface</classname>&lt; <classname>digit_parser</classname> &gt;</type><description><para>The decimal digit parser. Matches the full set of Unicode decimal digits; in other words, all Unicode code points with the "Nd" character property. Note that this covers all Unicode scripts, only a few of which are Latin. </para></description></data-member>
<data-member name="hex_digit"><type><emphasis>unspecified</emphasis></type><description><para>The hexidecimal digit parser. Matches the full set of Unicode hexidecimal digits (upper or lower case); in other words, all Unicode code points with the "Hex_Digit" character property. </para></description></data-member>
<data-member name="control"><type><emphasis>unspecified</emphasis></type><description><para>The control character parser. Matches the all Unicode code points with the "Cc" ("control character") character property. </para></description></data-member>
<data-member name="punct"><type><emphasis>unspecified</emphasis></type><description><para>The punctuation character parser. Matches the full set of Unicode punctuation clases (specifically, "Pc", "Pd", "Pe", "Pf", "Pi", "Ps", and "Po"). </para></description></data-member>
<data-member name="lower"><type><emphasis>unspecified</emphasis></type><description><para>The lower case character parser. Matches the full set of Unicode lower case code points (class "Ll"). </para></description></data-member>
<data-member name="upper"><type><emphasis>unspecified</emphasis></type><description><para>The lower case character parser. Matches the full set of Unicode lower case code points (class "Lu"). </para></description></data-member>
<data-member name="bool_"><type><classname>constexpr</classname> <classname>parser_interface</classname>&lt; <classname>bool_parser</classname> &gt;</type><description><para>The Boolean parser. Parses "true" and "false", producing attributes <computeroutput>true</computeroutput> and <computeroutput>false</computeroutput>, respectively, and fails on any other input. </para></description></data-member>
<data-member name="bin"><type><classname>constexpr</classname> <classname>parser_interface</classname>&lt; <classname>uint_parser</classname>&lt; <classname>unsigned</classname> <classname>int</classname>, 2 &gt; &gt;</type><description><para>The binary unsigned integer parser. Produces an <computeroutput>unsigned int</computeroutput> attribute. To parse a particular value <computeroutput>x</computeroutput>, use <computeroutput>bin(x)</computeroutput>. </para></description></data-member>
<data-member name="oct"><type><classname>constexpr</classname> <classname>parser_interface</classname>&lt; <classname>uint_parser</classname>&lt; <classname>unsigned</classname> <classname>int</classname>, 8 &gt; &gt;</type><description><para>The octal unsigned integer parser. Produces an <computeroutput>unsigned int</computeroutput> attribute. To parse a particular value <computeroutput>x</computeroutput>, use <computeroutput>oct(x)</computeroutput>. </para></description></data-member>
<data-member name="hex"><type><classname>constexpr</classname> <classname>parser_interface</classname>&lt; <classname>uint_parser</classname>&lt; <classname>unsigned</classname> <classname>int</classname>, 16 &gt; &gt;</type><description><para>The hexadecimal unsigned integer parser. Produces an <computeroutput>unsigned int</computeroutput> attribute. To parse a particular value <computeroutput>x</computeroutput>, use <computeroutput>hex(x)</computeroutput>. </para></description></data-member>
<data-member name="ushort_"><type><classname>constexpr</classname> <classname>parser_interface</classname>&lt; <classname>uint_parser</classname>&lt; <classname>unsigned</classname> <classname>short</classname> &gt; &gt;</type><description><para>The <computeroutput>unsigned short</computeroutput> parser. Produces an <computeroutput>unsigned short</computeroutput> attribute. To parse a particular value <computeroutput>x</computeroutput>, use <computeroutput>ushort_(x)</computeroutput>. </para></description></data-member>
<data-member name="uint_"><type><classname>constexpr</classname> <classname>parser_interface</classname>&lt; <classname>uint_parser</classname>&lt; <classname>unsigned</classname> <classname>int</classname> &gt; &gt;</type><description><para>The <computeroutput>unsigned int</computeroutput> parser. Produces an <computeroutput>unsigned int</computeroutput> attribute. To parse a particular value <computeroutput>x</computeroutput>, use <computeroutput>uint_(x)</computeroutput>. </para></description></data-member>
<data-member name="ulong_"><type><classname>constexpr</classname> <classname>parser_interface</classname>&lt; <classname>uint_parser</classname>&lt; <classname>unsigned</classname> <classname>long</classname> &gt; &gt;</type><description><para>The <computeroutput>unsigned long</computeroutput> parser. Produces an <computeroutput>unsigned long</computeroutput> attribute. To parse a particular value <computeroutput>x</computeroutput>, use <computeroutput>ulong_(x)</computeroutput>. </para></description></data-member>
<data-member name="ulong_long"><type><classname>constexpr</classname> <classname>parser_interface</classname>&lt; <classname>uint_parser</classname>&lt; <classname>unsigned</classname> <classname>long</classname> <classname>long</classname> &gt; &gt;</type><description><para>The <computeroutput>unsigned long long</computeroutput> parser. Produces an <computeroutput>unsigned long long</computeroutput> attribute. To parse a particular value <computeroutput>x</computeroutput>, use <computeroutput>ulong_long(x)</computeroutput>. </para></description></data-member>
<data-member name="short_"><type><classname>constexpr</classname> <classname>parser_interface</classname>&lt; <classname>int_parser</classname>&lt; <classname>short</classname> &gt; &gt;</type><description><para>The <computeroutput>short</computeroutput> parser. Produces a <computeroutput>short</computeroutput> attribute. To parse a particular value <computeroutput>x</computeroutput>, use <computeroutput>short_(x)</computeroutput>. </para></description></data-member>
<data-member name="int_"><type><classname>constexpr</classname> <classname>parser_interface</classname>&lt; <classname>int_parser</classname>&lt; <classname>int</classname> &gt; &gt;</type><description><para>The <computeroutput>int</computeroutput> parser. Produces an <computeroutput>int</computeroutput> attribute. To parse a particular value <computeroutput>x</computeroutput>, use <computeroutput>int_(x)</computeroutput>. </para></description></data-member>
<data-member name="long_"><type><classname>constexpr</classname> <classname>parser_interface</classname>&lt; <classname>int_parser</classname>&lt; <classname>long</classname> &gt; &gt;</type><description><para>The <computeroutput>long</computeroutput> parser. Produces a <computeroutput>long</computeroutput> attribute. To parse a particular value <computeroutput>x</computeroutput>, use <computeroutput>long_(x)</computeroutput>. </para></description></data-member>
<data-member name="long_long"><type><classname>constexpr</classname> <classname>parser_interface</classname>&lt; <classname>int_parser</classname>&lt; <classname>long</classname> <classname>long</classname> &gt; &gt;</type><description><para>The <computeroutput>long long</computeroutput> parser. Produces a <computeroutput>long long</computeroutput> attribute. To parse a particular value <computeroutput>x</computeroutput>, use <computeroutput>long_long(x)</computeroutput>. </para></description></data-member>
<data-member name="float_"><type><classname>constexpr</classname> <classname>parser_interface</classname>&lt; <classname>float_parser</classname>&lt; <classname>float</classname> &gt; &gt;</type><description><para>The <computeroutput>float</computeroutput> parser. Produces a <computeroutput>float</computeroutput> attribute. </para></description></data-member>
<data-member name="double_"><type><classname>constexpr</classname> <classname>parser_interface</classname>&lt; <classname>float_parser</classname>&lt; <classname>double</classname> &gt; &gt;</type><description><para>The <computeroutput>double</computeroutput> parser. Produces a <computeroutput>double</computeroutput> attribute. </para></description></data-member>





































<function name="with_globals"><type><classname>auto</classname></type><template>
          <template-type-parameter name="Parser"/>
          <template-type-parameter name="GlobalState"/>
          <template-type-parameter name="ErrorHandler"/>
        </template><parameter name="parser"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><parameter name="globals"><paramtype><classname>GlobalState</classname> &amp;</paramtype></parameter><description><para>Returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname></computeroutput> with the same parser and error handler, with <computeroutput>globals</computeroutput> added. The resut of passing any non-top-level parser for the <computeroutput>parser</computeroutput> argument is undefined. </para></description></function>
<function name="with_error_handler"><type><classname>auto</classname></type><template>
          <template-type-parameter name="Parser"/>
          <template-type-parameter name="GlobalState"/>
          <template-type-parameter name="ErrorHandler"/>
        </template><parameter name="parser"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>default_error_handler</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="error_handler"><paramtype><classname>ErrorHandler</classname> &amp;</paramtype></parameter><description><para>Returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname></computeroutput> with the same parser and globals, with <computeroutput>error_handler</computeroutput> added. The resut of passing any non-top-level parser for the <computeroutput>parser</computeroutput> argument is undefined. </para></description></function>
<function name="repeat"><type><classname>constexpr</classname> <classname>repeat_directive</classname>&lt; <classname>T</classname>, <classname>T</classname> &gt;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="n"><paramtype><classname>T</classname></paramtype></parameter><description><para>Returns a <computeroutput><classname alt="boost::parser::repeat_directive">repeat_directive</classname></computeroutput> that repeats exactly <computeroutput>n</computeroutput> times, and whose <computeroutput>operator[]</computeroutput> returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname>&lt;<classname alt="boost::parser::repeat_parser">repeat_parser</classname>&lt;P&gt;&gt;</computeroutput> from a given parser of type <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname>&lt;P&gt;</computeroutput>. </para></description></function>
<function name="repeat"><type><classname>constexpr</classname> <classname>repeat_directive</classname>&lt; <classname>MinType</classname>, <classname>MaxType</classname> &gt;</type><template>
          <template-type-parameter name="MinType"/>
          <template-type-parameter name="MaxType"/>
        </template><parameter name="min_"><paramtype><classname>MinType</classname></paramtype></parameter><parameter name="max_"><paramtype><classname>MaxType</classname></paramtype></parameter><description><para>Returns a <computeroutput><classname alt="boost::parser::repeat_directive">repeat_directive</classname></computeroutput> that repeats between <computeroutput>min_</computeroutput> and <computeroutput>max_</computeroutput> times, inclusive, and whose <computeroutput>operator[]</computeroutput> returns a <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname>&lt;<classname alt="boost::parser::repeat_parser">repeat_parser</classname>&lt;P&gt;&gt;</computeroutput> from a given parser of type <computeroutput><classname alt="boost::parser::parser_interface">parser_interface</classname>&lt;P&gt;</computeroutput>. </para></description></function>
<function name="transform"><type><classname>auto</classname></type><template>
          <template-type-parameter name="F"/>
        </template><parameter name="f"><paramtype>F</paramtype></parameter><description><para>Returns a <computeroutput><classname alt="boost::parser::transform_directive">transform_directive</classname></computeroutput> that uses invocable <computeroutput>F</computeroutput> to do its work. </para></description></function>
<function name="attr"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-type-parameter name="Attribute"/>
        </template><parameter name="a"><paramtype><classname>Attribute</classname></paramtype></parameter><description><para>Returns an <computeroutput><classname alt="boost::parser::attr_parser">attr_parser</classname></computeroutput> which matches anything, and consumes no input, and which produces <computeroutput>a</computeroutput> as its attribute. </para></description></function>
<function name="lit"><type><classname>constexpr</classname> <classname>auto</classname></type><parameter name="c"><paramtype><classname>char</classname></paramtype></parameter><description><para>Returns a literal code point parser that produces no attribute. </para></description></function>
<function name="lit"><type><classname>constexpr</classname> <classname>auto</classname></type><parameter name="c"><paramtype><classname>char8_t</classname></paramtype></parameter><description><para>Returns a literal code point parser that produces no attribute. </para></description></function>
<function name="lit"><type><classname>constexpr</classname> <classname>auto</classname></type><parameter name="c"><paramtype><classname>char32_t</classname></paramtype></parameter><description><para>Returns a literal code point parser that produces no attribute. </para></description></function>
<function name="string"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-nontype-parameter name="R"><type>parsable_range_like</type></template-nontype-parameter>
        </template><parameter name="str"><paramtype><classname>R</classname> &amp;&amp;</paramtype></parameter><description><para>Returns a parser that matches <computeroutput>str</computeroutput> that produces the matched string as its attribute. </para></description></function>
<function name="lit"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-nontype-parameter name="R"><type>parsable_range_like</type></template-nontype-parameter>
        </template><parameter name="str"><paramtype><classname>R</classname> &amp;&amp;</paramtype></parameter><description><para>Returns a parser that matches <computeroutput>str</computeroutput> that produces no attribute. </para></description></function>
<function name="if_"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-type-parameter name="Predicate"/>
        </template><parameter name="pred"><paramtype><classname>Predicate</classname></paramtype></parameter><description><para>Returns an <computeroutput><classname alt="boost::parser::if_directive">if_directive</classname></computeroutput> that fails if the given predicate <computeroutput>pred</computeroutput> is <computeroutput>false</computeroutput>, and otherwise, applies another parser. For instance, in <computeroutput>if_(pred)[p]</computeroutput>, <computeroutput>p</computeroutput> is only applied if <computeroutput>pred</computeroutput> is true. </para></description></function>
<function name="switch_"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="x"><paramtype><classname>T</classname></paramtype></parameter><description><para>Returns a <computeroutput>switch</computeroutput>-like parser. The resulting parser uses the given value <computeroutput>x</computeroutput> to select one of the following value/parser pairs, and to apply the selected parser. <computeroutput>x</computeroutput> may be a value to be used directly, or a unary invocable that takes a reference to the parse context, and returns the value to use. You can add more value/parser cases to the returned parser, using its call operator, e.g. <computeroutput>switch_(x)(y1, p1)(y2, p2)</computeroutput>. As with the <computeroutput>x</computeroutput> passed to this function, each <computeroutput>yN</computeroutput> value can be a value or a unary invocable. </para></description></function>
<function name="operator&gt;&gt;"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-type-parameter name="Parser"/>
        </template><parameter name="c"><paramtype><classname>char</classname></paramtype></parameter><parameter name="rhs"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname> &gt;</paramtype></parameter><description><para>Returns a parser equivalent to <computeroutput>lit(c) &gt;&gt; rhs</computeroutput>. </para></description></function>
<function name="operator&gt;&gt;"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-type-parameter name="Parser"/>
        </template><parameter name="c"><paramtype><classname>char32_t</classname></paramtype></parameter><parameter name="rhs"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname> &gt;</paramtype></parameter><description><para>Returns a parser equivalent to <computeroutput>lit(c) &gt;&gt; rhs</computeroutput>. </para></description></function>
<function name="operator&gt;&gt;"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-nontype-parameter name="R"><type>parsable_range_like</type></template-nontype-parameter>
          <template-type-parameter name="Parser"/>
        </template><parameter name="r"><paramtype><classname>R</classname> &amp;&amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname> &gt;</paramtype></parameter><description><para>Returns a parser equivalent to <computeroutput>lit(str) &gt;&gt; rhs</computeroutput>. </para></description></function>
<function name="operator&gt;"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-type-parameter name="Parser"/>
        </template><parameter name="c"><paramtype><classname>char</classname></paramtype></parameter><parameter name="rhs"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname> &gt;</paramtype></parameter><description><para>Returns a parser equivalent to <computeroutput>lit(c) &gt; rhs</computeroutput>. </para></description></function>
<function name="operator&gt;"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-type-parameter name="Parser"/>
        </template><parameter name="c"><paramtype><classname>char32_t</classname></paramtype></parameter><parameter name="rhs"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname> &gt;</paramtype></parameter><description><para>Returns a parser equivalent to <computeroutput>lit(c) &gt; rhs</computeroutput>. </para></description></function>
<function name="operator&gt;"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-nontype-parameter name="R"><type>parsable_range_like</type></template-nontype-parameter>
          <template-type-parameter name="Parser"/>
        </template><parameter name="r"><paramtype><classname>R</classname> &amp;&amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname> &gt;</paramtype></parameter><description><para>Returns a parser equivalent to <computeroutput>lit(str) &gt; rhs</computeroutput>. </para></description></function>
<function name="operator|"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-type-parameter name="Parser"/>
        </template><parameter name="c"><paramtype><classname>char</classname></paramtype></parameter><parameter name="rhs"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname> &gt;</paramtype></parameter><description><para>Returns a parser equivalent to <computeroutput>lit(c) | rhs</computeroutput>. </para></description></function>
<function name="operator|"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-type-parameter name="Parser"/>
        </template><parameter name="c"><paramtype><classname>char32_t</classname></paramtype></parameter><parameter name="rhs"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname> &gt;</paramtype></parameter><description><para>Returns a parser equivalent to <computeroutput>lit(c) | rhs</computeroutput>. </para></description></function>
<function name="operator|"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-nontype-parameter name="R"><type>parsable_range_like</type></template-nontype-parameter>
          <template-type-parameter name="Parser"/>
        </template><parameter name="r"><paramtype><classname>R</classname> &amp;&amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname> &gt;</paramtype></parameter><description><para>Returns a parser equivalent to <computeroutput>lit(str) | rhs</computeroutput>. </para></description></function>
<function name="operator-"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-type-parameter name="Parser"/>
        </template><parameter name="c"><paramtype><classname>char</classname></paramtype></parameter><parameter name="rhs"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname> &gt;</paramtype></parameter><description><para>Returns a parser equivalent to <computeroutput>!rhs &gt;&gt; lit(c)</computeroutput>. </para></description></function>
<function name="operator-"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-type-parameter name="Parser"/>
        </template><parameter name="c"><paramtype><classname>char32_t</classname></paramtype></parameter><parameter name="rhs"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname> &gt;</paramtype></parameter><description><para>Returns a parser equivalent to <computeroutput>!rhs &gt;&gt; lit(c)</computeroutput>. </para></description></function>
<function name="operator-"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-nontype-parameter name="R"><type>parsable_range_like</type></template-nontype-parameter>
          <template-type-parameter name="Parser"/>
        </template><parameter name="r"><paramtype><classname>R</classname> &amp;&amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname> &gt;</paramtype></parameter><description><para>Returns a parser equivalent to <computeroutput>!rhs &gt;&gt; lit(str)</computeroutput>. </para></description></function>
<function name="operator%"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-type-parameter name="Parser"/>
        </template><parameter name="c"><paramtype><classname>char</classname></paramtype></parameter><parameter name="rhs"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname> &gt;</paramtype></parameter><description><para>Returns a parser equivalent to <computeroutput>lit(c) % rhs</computeroutput>. </para></description></function>
<function name="operator%"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-type-parameter name="Parser"/>
        </template><parameter name="c"><paramtype><classname>char32_t</classname></paramtype></parameter><parameter name="rhs"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname> &gt;</paramtype></parameter><description><para>Returns a parser equivalent to <computeroutput>lit(c) % rhs</computeroutput>. </para></description></function>
<function name="operator%"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-nontype-parameter name="R"><type>parsable_range_like</type></template-nontype-parameter>
          <template-type-parameter name="Parser"/>
        </template><parameter name="r"><paramtype><classname>R</classname> &amp;&amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname> &gt;</paramtype></parameter><description><para>Returns a parser equivalent to <computeroutput>lit(str) % rhs</computeroutput>. </para></description></function>
<function name="prefix_parse"><type><classname>bool</classname></type><template>
          <template-nontype-parameter name="I"><type>parsable_iter</type></template-nontype-parameter>
          <template-nontype-parameter name="S"><type>std::sentinel_for&lt; I &gt;</type></template-nontype-parameter>
          <template-type-parameter name="Parser"/>
          <template-type-parameter name="GlobalState"/>
          <template-nontype-parameter name="ErrorHandler"><type>error_handler&lt; I, S, GlobalState &gt;</type></template-nontype-parameter>
          <template-type-parameter name="Attr"><purpose><para>Constrained by <computeroutput>!detail::derived_from_parser_interface_v&lt;std::remove_cvref_t&lt;Attr&gt;</computeroutput>. </para></purpose></template-type-parameter>
        </template><parameter name="first"><paramtype>I &amp;</paramtype></parameter><parameter name="last"><paramtype>S</paramtype></parameter><parameter name="parser"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="attr"><paramtype><classname>Attr</classname> &amp;</paramtype></parameter><parameter name="trace_mode"><paramtype>trace</paramtype><default>trace::off</default></parameter><description><para>Parses <computeroutput>[first, last)</computeroutput> using <computeroutput>parser</computeroutput>, and returns whether the parse was successful. On success, <computeroutput>attr</computeroutput> will be assigned the value of the attribute produced by <computeroutput>parser</computeroutput>. If <computeroutput>trace_mode == trace::on</computeroutput>, a verbose trace of the parse will be streamed to <computeroutput>std::cout</computeroutput>.</para><para>
</para></description></function>
<function name="parse"><type><classname>bool</classname></type><template>
          <template-nontype-parameter name="R"><type>parsable_range</type></template-nontype-parameter>
          <template-type-parameter name="Parser"/>
          <template-type-parameter name="GlobalState"/>
          <template-type-parameter name="ErrorHandler"><purpose><para>Constrained by <computeroutput>error_handler&lt;ErrorHandler,std::ranges::iterator_t&lt;decltype(subrange_of(r))&gt;, std::ranges::sentinel_t&lt;decltype(subrange_of(r))&gt;, GlobalState&gt;</computeroutput>, where <computeroutput>subrange_of</computeroutput> is an implementation detail that: creates subranges out of pointers; trims trailing zeros off of bounded arrays (such as string literals); and transcodes to UTF-32 if the input is non-<computeroutput>char</computeroutput>. </para></purpose></template-type-parameter>
          <template-type-parameter name="Attr"><purpose><para>Constrained by <computeroutput>!detail::derived_from_parser_interface_v&lt;std::remove_cvref_t&lt;Attr&gt;</computeroutput>. </para></purpose></template-type-parameter>
        </template><parameter name="r"><paramtype><classname>R</classname> <classname>const</classname> &amp;</paramtype></parameter><parameter name="parser"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="attr"><paramtype><classname>Attr</classname> &amp;</paramtype></parameter><parameter name="trace_mode"><paramtype>trace</paramtype><default>trace::off</default></parameter><description><para>Parses <computeroutput>r</computeroutput> using <computeroutput>parser</computeroutput>, and returns whether the parse was successful. The entire input range <computeroutput>r</computeroutput> must be consumed for the parse to be considered successful. On success, <computeroutput>attr</computeroutput> will be assigned the value of the attribute produced by <computeroutput>parser</computeroutput>. If <computeroutput>trace_mode == trace::on</computeroutput>, a verbose trace of the parse will be streamed to <computeroutput>std::cout</computeroutput>.</para><para>
</para></description></function>
<function name="prefix_parse"><type><classname>auto</classname></type><template>
          <template-nontype-parameter name="I"><type>parsable_iter</type></template-nontype-parameter>
          <template-nontype-parameter name="S"><type>std::sentinel_for&lt; I &gt;</type></template-nontype-parameter>
          <template-type-parameter name="Parser"/>
          <template-type-parameter name="GlobalState"/>
          <template-nontype-parameter name="ErrorHandler"><type>error_handler&lt; I, S, GlobalState &gt;</type></template-nontype-parameter>
        </template><parameter name="first"><paramtype>I &amp;</paramtype></parameter><parameter name="last"><paramtype>S</paramtype></parameter><parameter name="parser"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="trace_mode"><paramtype>trace</paramtype><default>trace::off</default></parameter><description><para>Parses <computeroutput>[first, last)</computeroutput> using <computeroutput>parser</computeroutput>. Returns a <computeroutput>std::optional</computeroutput> containing the attribute produced by <computeroutput>parser</computeroutput> on parse success, and <computeroutput>std::nullopt</computeroutput> on parse failure. If <computeroutput>trace_mode == trace::on</computeroutput>, a verbose trace of the parse will be streamed to <computeroutput>std::cout</computeroutput>.</para><para>
</para></description></function>
<function name="parse"><type><classname>auto</classname></type><template>
          <template-nontype-parameter name="R"><type>parsable_range</type></template-nontype-parameter>
          <template-type-parameter name="Parser"/>
          <template-type-parameter name="GlobalState"/>
          <template-type-parameter name="ErrorHandler"><purpose><para>Constrained by <computeroutput>error_handler&lt;ErrorHandler,std::ranges::iterator_t&lt;decltype(subrange_of(r))&gt;, std::ranges::sentinel_t&lt;decltype(subrange_of(r))&gt;, GlobalState&gt;</computeroutput>, where <computeroutput>subrange_of</computeroutput> is an implementation detail that: creates subranges out of pointers; trims trailing zeros off of bounded arrays (such as string literals); and transcodes to UTF-32 if the input is non-<computeroutput>char</computeroutput>. </para></purpose></template-type-parameter>
        </template><parameter name="r"><paramtype><classname>R</classname> <classname>const</classname> &amp;</paramtype></parameter><parameter name="parser"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="trace_mode"><paramtype>trace</paramtype><default>trace::off</default></parameter><description><para>Parses <computeroutput>r</computeroutput> using <computeroutput>parser</computeroutput>. Returns a <computeroutput>std::optional</computeroutput> containing the attribute produced by <computeroutput>parser</computeroutput> on parse success, and <computeroutput>std::nullopt</computeroutput> on parse failure. The entire input range <computeroutput>r</computeroutput> must be consumed for the parse to be considered successful. If <computeroutput>trace_mode == trace::on</computeroutput>, a verbose trace of the parse will be streamed to <computeroutput>std::cout</computeroutput>.</para><para>
</para></description></function>
<function name="prefix_parse"><type><classname>bool</classname></type><template>
          <template-nontype-parameter name="I"><type>parsable_iter</type></template-nontype-parameter>
          <template-nontype-parameter name="S"><type>std::sentinel_for&lt; I &gt;</type></template-nontype-parameter>
          <template-type-parameter name="Parser"/>
          <template-type-parameter name="GlobalState"/>
          <template-nontype-parameter name="ErrorHandler"><type>error_handler&lt; I, S, GlobalState &gt;</type></template-nontype-parameter>
          <template-type-parameter name="SkipParser"/>
          <template-type-parameter name="Attr"/>
        </template><parameter name="first"><paramtype>I &amp;</paramtype></parameter><parameter name="last"><paramtype>S</paramtype></parameter><parameter name="parser"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="skip"><paramtype><classname>parser_interface</classname>&lt; <classname>SkipParser</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="attr"><paramtype><classname>Attr</classname> &amp;</paramtype></parameter><parameter name="trace_mode"><paramtype>trace</paramtype><default>trace::off</default></parameter><description><para>Parses <computeroutput>[first, last)</computeroutput> using <computeroutput>parser</computeroutput>, skipping all input recognized by <computeroutput>skip</computeroutput> between the application of any two parsers, and returns whether the parse was successful. On success, <computeroutput>attr</computeroutput> will be assigned the value of the attribute produced by <computeroutput>parser</computeroutput>. If <computeroutput>trace_mode == trace::on</computeroutput>, a verbose trace of the parse will be streamed to <computeroutput>std::cout</computeroutput>. </para></description></function>
<function name="parse"><type><classname>bool</classname></type><template>
          <template-nontype-parameter name="R"><type>parsable_range</type></template-nontype-parameter>
          <template-type-parameter name="Parser"/>
          <template-type-parameter name="GlobalState"/>
          <template-type-parameter name="ErrorHandler"><purpose><para>Constrained by <computeroutput>error_handler&lt;ErrorHandler,std::ranges::iterator_t&lt;decltype(subrange_of(r))&gt;, std::ranges::sentinel_t&lt;decltype(subrange_of(r))&gt;, GlobalState&gt;</computeroutput>, where <computeroutput>subrange_of</computeroutput> is an implementation detail that: creates subranges out of pointers; trims trailing zeros off of bounded arrays (such as string literals); and transcodes to UTF-32 if the input is non-<computeroutput>char</computeroutput>. </para></purpose></template-type-parameter>
          <template-type-parameter name="SkipParser"/>
          <template-type-parameter name="Attr"/>
        </template><parameter name="r"><paramtype><classname>R</classname> <classname>const</classname> &amp;</paramtype></parameter><parameter name="parser"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="skip"><paramtype><classname>parser_interface</classname>&lt; <classname>SkipParser</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="attr"><paramtype><classname>Attr</classname> &amp;</paramtype></parameter><parameter name="trace_mode"><paramtype>trace</paramtype><default>trace::off</default></parameter><description><para>Parses <computeroutput>r</computeroutput> using <computeroutput>parser</computeroutput>, skipping all input recognized by <computeroutput>skip</computeroutput> between the application of any two parsers, and returns whether the parse was successful. The entire input range <computeroutput>r</computeroutput> must be consumed for the parse to be considered successful. On success, <computeroutput>attr</computeroutput> will be assigned the value of the attribute produced by <computeroutput>parser</computeroutput>. If <computeroutput>trace_mode == trace::on</computeroutput>, a verbose trace of the parse will be streamed to <computeroutput>std::cout</computeroutput>.</para><para>
</para></description></function>
<function name="prefix_parse"><type><classname>auto</classname></type><template>
          <template-nontype-parameter name="I"><type>parsable_iter</type></template-nontype-parameter>
          <template-nontype-parameter name="S"><type>std::sentinel_for&lt; I &gt;</type></template-nontype-parameter>
          <template-type-parameter name="Parser"/>
          <template-type-parameter name="GlobalState"/>
          <template-nontype-parameter name="ErrorHandler"><type>error_handler&lt; I, S, GlobalState &gt;</type></template-nontype-parameter>
          <template-type-parameter name="SkipParser"/>
        </template><parameter name="first"><paramtype>I &amp;</paramtype></parameter><parameter name="last"><paramtype>S</paramtype></parameter><parameter name="parser"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="skip"><paramtype><classname>parser_interface</classname>&lt; <classname>SkipParser</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="trace_mode"><paramtype>trace</paramtype><default>trace::off</default></parameter><description><para>Parses <computeroutput>[first, last)</computeroutput> using <computeroutput>parser</computeroutput>, skipping all input recognized by <computeroutput>skip</computeroutput> between the application of any two parsers. Returns a <computeroutput>std::optional</computeroutput> containing the attribute produced by <computeroutput>parser</computeroutput> on parse success, and <computeroutput>std::nullopt</computeroutput> on parse failure. If <computeroutput>trace_mode == trace::on</computeroutput>, a verbose trace of the parse will be streamed to <computeroutput>std::cout</computeroutput>. </para></description></function>
<function name="parse"><type><classname>auto</classname></type><template>
          <template-nontype-parameter name="R"><type>parsable_range</type></template-nontype-parameter>
          <template-type-parameter name="Parser"/>
          <template-type-parameter name="GlobalState"/>
          <template-type-parameter name="ErrorHandler"><purpose><para>Constrained by <computeroutput>error_handler&lt;ErrorHandler,std::ranges::iterator_t&lt;decltype(subrange_of(r))&gt;, std::ranges::sentinel_t&lt;decltype(subrange_of(r))&gt;, GlobalState&gt;</computeroutput>, where <computeroutput>subrange_of</computeroutput> is an implementation detail that: creates subranges out of pointers; trims trailing zeros off of bounded arrays (such as string literals); and transcodes to UTF-32 if the input is non-<computeroutput>char</computeroutput>. </para></purpose></template-type-parameter>
          <template-type-parameter name="SkipParser"/>
        </template><parameter name="r"><paramtype><classname>R</classname> <classname>const</classname> &amp;</paramtype></parameter><parameter name="parser"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="skip"><paramtype><classname>parser_interface</classname>&lt; <classname>SkipParser</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="trace_mode"><paramtype>trace</paramtype><default>trace::off</default></parameter><description><para>Parses <computeroutput>r</computeroutput> using <computeroutput>parser</computeroutput>, skipping all input recognized by <computeroutput>skip</computeroutput> between the application of any two parsers. Returns a <computeroutput>std::optional</computeroutput> containing the attribute produced by <computeroutput>parser</computeroutput> on parse success, and <computeroutput>std::nullopt</computeroutput> on parse failure. The entire input range <computeroutput>r</computeroutput> must be consumed for the parse to be considered successful. If <computeroutput>trace_mode == trace::on</computeroutput>, a verbose trace of the parse will be streamed to <computeroutput>std::cout</computeroutput>.</para><para>
</para></description></function>
<function name="callback_prefix_parse"><type><classname>bool</classname></type><template>
          <template-nontype-parameter name="I"><type>parsable_iter</type></template-nontype-parameter>
          <template-nontype-parameter name="S"><type>std::sentinel_for&lt; I &gt;</type></template-nontype-parameter>
          <template-type-parameter name="Parser"/>
          <template-type-parameter name="GlobalState"/>
          <template-nontype-parameter name="ErrorHandler"><type>error_handler&lt; I, S, GlobalState &gt;</type></template-nontype-parameter>
          <template-type-parameter name="Callbacks"/>
        </template><parameter name="first"><paramtype>I &amp;</paramtype></parameter><parameter name="last"><paramtype>S</paramtype></parameter><parameter name="parser"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="callbacks"><paramtype><classname>Callbacks</classname> <classname>const</classname> &amp;</paramtype></parameter><parameter name="trace_mode"><paramtype>trace</paramtype><default>trace::off</default></parameter><description><para>Parses <computeroutput>[first, last)</computeroutput> using <computeroutput>parser</computeroutput>, and returns whether the parse was successful. When a callback rule <computeroutput>r</computeroutput> is successful during the parse, one of two things happens: 1) if <computeroutput>r</computeroutput> has an attribute, <computeroutput>callbacks(tag, x)</computeroutput> will be called (where <computeroutput>tag</computeroutput> is <computeroutput>decltype(r)::tag_type{}</computeroutput>, and <computeroutput>x</computeroutput> is the attribute produced by <computeroutput>r</computeroutput>); or 2) if <computeroutput>r</computeroutput> has no attribute, <computeroutput>callbacks(tag)</computeroutput> will be called. <computeroutput>Callbacks</computeroutput> is expected to be an invocable with the correct overloads required to support all successful rule parses that might occur. If <computeroutput>trace_mode == trace::on</computeroutput>, a verbose trace of the parse will be streamed to <computeroutput>std::cout</computeroutput>. </para></description></function>
<function name="callback_parse"><type><classname>bool</classname></type><template>
          <template-nontype-parameter name="R"><type>parsable_range</type></template-nontype-parameter>
          <template-type-parameter name="Parser"/>
          <template-type-parameter name="GlobalState"/>
          <template-type-parameter name="ErrorHandler"><purpose><para>Constrained by <computeroutput>error_handler&lt;ErrorHandler,std::ranges::iterator_t&lt;decltype(subrange_of(r))&gt;, std::ranges::sentinel_t&lt;decltype(subrange_of(r))&gt;, GlobalState&gt;</computeroutput>, where <computeroutput>subrange_of</computeroutput> is an implementation detail that: creates subranges out of pointers; trims trailing zeros off of bounded arrays (such as string literals); and transcodes to UTF-32 if the input is non-<computeroutput>char</computeroutput>. </para></purpose></template-type-parameter>
          <template-type-parameter name="Callbacks"/>
        </template><parameter name="r"><paramtype><classname>R</classname> <classname>const</classname> &amp;</paramtype></parameter><parameter name="parser"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="callbacks"><paramtype><classname>Callbacks</classname> <classname>const</classname> &amp;</paramtype></parameter><parameter name="trace_mode"><paramtype>trace</paramtype><default>trace::off</default></parameter><description><para>Parses <computeroutput>r</computeroutput> using <computeroutput>parser</computeroutput>, and returns whether the parse was successful. The entire input range <computeroutput>r</computeroutput> must be consumed for the parse to be considered successful. When a callback rule <computeroutput>r</computeroutput> is successful during the parse, one of two things happens: 1) if <computeroutput>r</computeroutput> has an attribute, <computeroutput>callbacks(tag, x)</computeroutput> will be called (where <computeroutput>tag</computeroutput> is <computeroutput>decltype(r)::tag_type{}</computeroutput>, and <computeroutput>x</computeroutput> is the attribute produced by <computeroutput>r</computeroutput>); or 2) if <computeroutput>r</computeroutput> has no attribute, <computeroutput>callbacks(tag)</computeroutput> will be called. <computeroutput>Callbacks</computeroutput> is expected to be an invocable with the correct overloads required to support all successful rule parses that might occur. If <computeroutput>trace_mode == trace::on</computeroutput>, a verbose trace of the parse will be streamed to <computeroutput>std::cout</computeroutput>.</para><para>
</para></description></function>
<function name="callback_prefix_parse"><type><classname>bool</classname></type><template>
          <template-nontype-parameter name="I"><type>parsable_iter</type></template-nontype-parameter>
          <template-nontype-parameter name="S"><type>std::sentinel_for&lt; I &gt;</type></template-nontype-parameter>
          <template-type-parameter name="Parser"/>
          <template-type-parameter name="GlobalState"/>
          <template-nontype-parameter name="ErrorHandler"><type>error_handler&lt; I, S, GlobalState &gt;</type></template-nontype-parameter>
          <template-type-parameter name="SkipParser"/>
          <template-type-parameter name="Callbacks"/>
        </template><parameter name="first"><paramtype>I &amp;</paramtype></parameter><parameter name="last"><paramtype>S</paramtype></parameter><parameter name="parser"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="skip"><paramtype><classname>parser_interface</classname>&lt; <classname>SkipParser</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="callbacks"><paramtype><classname>Callbacks</classname> <classname>const</classname> &amp;</paramtype></parameter><parameter name="trace_mode"><paramtype>trace</paramtype><default>trace::off</default></parameter><description><para>Parses <computeroutput>[first, last)</computeroutput> using <computeroutput>parser</computeroutput>, skipping all input recognized by <computeroutput>skip</computeroutput> between the application of any two parsers, and returns whether the parse was successful. When a callback rule <computeroutput>r</computeroutput> is successful during the parse, one of two things happens: 1) if <computeroutput>r</computeroutput> has an attribute, <computeroutput>callbacks(tag, x)</computeroutput> will be called (where <computeroutput>tag</computeroutput> is <computeroutput>decltype(r)::tag_type{}</computeroutput>, and <computeroutput>x</computeroutput> is the attribute produced by <computeroutput>r</computeroutput>); or 2) if <computeroutput>r</computeroutput> has no attribute, <computeroutput>callbacks(tag)</computeroutput> will be called. <computeroutput>Callbacks</computeroutput> is expected to be an invocable with the correct overloads required to support all successful rule parses that might occur. If <computeroutput>trace_mode == trace::on</computeroutput>, a verbose trace of the parse will be streamed to <computeroutput>std::cout</computeroutput>. </para></description></function>
<function name="callback_parse"><type><classname>bool</classname></type><template>
          <template-nontype-parameter name="R"><type>parsable_range</type></template-nontype-parameter>
          <template-type-parameter name="Parser"/>
          <template-type-parameter name="GlobalState"/>
          <template-type-parameter name="ErrorHandler"><purpose><para>Constrained by <computeroutput>error_handler&lt;ErrorHandler,std::ranges::iterator_t&lt;decltype(subrange_of(r))&gt;, std::ranges::sentinel_t&lt;decltype(subrange_of(r))&gt;, GlobalState&gt;</computeroutput>, where <computeroutput>subrange_of</computeroutput> is an implementation detail that: creates subranges out of pointers; trims trailing zeros off of bounded arrays (such as string literals); and transcodes to UTF-32 if the input is non-<computeroutput>char</computeroutput>. </para></purpose></template-type-parameter>
          <template-type-parameter name="SkipParser"/>
          <template-type-parameter name="Callbacks"/>
        </template><parameter name="r"><paramtype><classname>R</classname> <classname>const</classname> &amp;</paramtype></parameter><parameter name="parser"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="skip"><paramtype><classname>parser_interface</classname>&lt; <classname>SkipParser</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="callbacks"><paramtype><classname>Callbacks</classname> <classname>const</classname> &amp;</paramtype></parameter><parameter name="trace_mode"><paramtype>trace</paramtype><default>trace::off</default></parameter><description><para>Parses <computeroutput>r</computeroutput> using <computeroutput>parser</computeroutput>, skipping all input recognized by <computeroutput>skip</computeroutput> between the application of any two parsers, and returns whether the parse was successful. The entire input range <computeroutput>r</computeroutput> must be consumed for the parse to be considered successful. When a callback rule <computeroutput>r</computeroutput> is successful during the parse, one of two things happens: 1) if <computeroutput>r</computeroutput> has an attribute, <computeroutput>callbacks(tag, x)</computeroutput> will be called (where <computeroutput>tag</computeroutput> is <computeroutput>decltype(r)::tag_type{}</computeroutput>, and <computeroutput>x</computeroutput> is the attribute produced by <computeroutput>r</computeroutput>); or 2) if <computeroutput>r</computeroutput> has no attribute, <computeroutput>callbacks(tag)</computeroutput> will be called. <computeroutput>Callbacks</computeroutput> is expected to be an invocable with the correct overloads required to support all successful rule parses that might occur. If <computeroutput>trace_mode == trace::on</computeroutput>, a verbose trace of the parse will be streamed to <computeroutput>std::cout</computeroutput>.</para><para>
</para></description></function>






</namespace>
</namespace>
<macro name="BOOST_PARSER_DEFINE_RULES" kind="functionlike"><macro-parameter name="..."/><description><para>For each given token <computeroutput>t</computeroutput>, defines a pair of <computeroutput>parse_rule()</computeroutput> overloads, used internally within Boost.Parser. Each such pair implements the parsing behavior rule <computeroutput>t</computeroutput>, using the parser <computeroutput>t_def</computeroutput>. This implementation is in the form of a pair of function templates. You should therefore write this macro only at namespace scope. </para></description></macro>
</header>
<header name="boost/parser/parser_fwd.hpp">
<namespace name="boost">
<namespace name="parser">
<struct name="action_parser"><template>
      <template-type-parameter name="Parser"/>
      <template-type-parameter name="Action"/>
    </template><description><para>Applies the given parser <computeroutput>p</computeroutput> of type <computeroutput>Parser</computeroutput> and an invocable <computeroutput>a</computeroutput> of type <computeroutput>Action</computeroutput>. <computeroutput>Action</computeroutput> shall model <computeroutput>semantic_action</computeroutput>, and <computeroutput>a</computeroutput> will only be invoked if <computeroutput>p</computeroutput> succeeds. The parse succeeds iff <computeroutput>p</computeroutput> succeeds. Produces no attribute. </para></description></struct><struct name="attr_parser"><template>
      <template-type-parameter name="Attribute"/>
    </template><description><para>Matches anything, consumes no input, and produces an attribute of type <computeroutput>RESOLVE(Attribute)</computeroutput>. </para></description></struct><struct name="callback_rule"><template>
      <template-type-parameter name="TagType"/>
      <template-type-parameter name="Attribute"><default>no_attribute</default></template-type-parameter>
      <template-type-parameter name="LocalState"><default>no_local_state</default></template-type-parameter>
      <template-type-parameter name="ParamsTuple"><default>no_params</default></template-type-parameter>
    </template><description><para>A type used to declare named parsing rules that support reporting of attributes via callback. The <computeroutput>TagType</computeroutput> template parameter is used to associate a particular <computeroutput>rule</computeroutput> with the <computeroutput><classname alt="boost::parser::rule_parser">rule_parser</classname></computeroutput> used during parsing. </para></description></struct><struct name="char_parser"><template>
      <template-type-parameter name="Expected"/>
      <template-type-parameter name="AttributeType"><default><classname alt="boost::parser::parse_error">void</classname></default></template-type-parameter>
    </template><description><para>Matches a single code point. If <computeroutput>AttributeType</computeroutput> is not <computeroutput>void</computeroutput>, <computeroutput>AttributeType</computeroutput> is the attribute type produced; otherwise, the attribute type is the decayed type of the matched code point. The parse fails only if the parser is constructed with a specific set of expected code point values that does not include the matched code point. </para></description></struct><struct name="char_set_parser"><template>
      <template-type-parameter name="Tag"/>
    </template><description><para>Matches a single code point that is equal to one of the code points associated with tag type <computeroutput>Tag</computeroutput>. This is used to create sets of characters for matching Unicode character classes like punctuation or lower case. Attribute type is the attribute type of the character being matched. </para></description></struct><struct name="char_subrange_parser"><template>
      <template-type-parameter name="Tag"/>
    </template><description><para>Matches a single code point that falls into one of the subranges of code points associated with tag type <computeroutput>Tag</computeroutput>. This is used to create sets of characters for matching Unicode character classes like hex digits or control characters. Attribute type is the attribute type of the character being matched. </para></description></struct><struct name="eps_parser"><template>
      <template-type-parameter name="Predicate"/>
    </template><description><para>Matches anything, and consumes no input. If <computeroutput>Predicate</computeroutput> is anything other than <computeroutput><classname alt="boost::parser::detail::nope">detail::nope</classname></computeroutput> (which it is by default), and <computeroutput>pred_(ctx)</computeroutput> evaluates to false, where <computeroutput>ctx</computeroutput> is the parser context, the parse fails. </para></description></struct><struct name="expect_parser"><template>
      <template-type-parameter name="Parser"/>
      <template-nontype-parameter name="FailOnMatch"><type><classname>bool</classname></type></template-nontype-parameter>
    </template><description><para>Applies the given parser <computeroutput>p</computeroutput> of type <computeroutput>Parser</computeroutput>, producing no attributes and consuming no input. The parse succeeds iff <computeroutput>p</computeroutput>'s success is unequal to <computeroutput>FailOnMatch</computeroutput>. </para></description></struct><struct name="float_parser"><template>
      <template-type-parameter name="T"/>
    </template><description><para>Matches a floating point number, producing an attribute of type <computeroutput>T</computeroutput>. </para></description></struct><struct name="int_parser"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Radix"><type><classname>int</classname></type><default>10</default></template-nontype-parameter>
      <template-nontype-parameter name="MinDigits"><type><classname>int</classname></type><default>1</default></template-nontype-parameter>
      <template-nontype-parameter name="MaxDigits"><type><classname>int</classname></type><default>-1</default></template-nontype-parameter>
      <template-type-parameter name="Expected"><default><classname alt="boost::parser::detail::nope">detail::nope</classname></default></template-type-parameter>
    </template><description><para>Matches a signed number of radix <computeroutput>Radix</computeroutput>, of at least <computeroutput>MinDigits</computeroutput> and at most <computeroutput>MaxDigits</computeroutput>, producing an attribute of type <computeroutput>T</computeroutput>. Fails on any other input. The parse will also fail if <computeroutput>Expected</computeroutput> is anything but <computeroutput><classname alt="boost::parser::detail::nope">detail::nope</classname></computeroutput> (which it is by default), and the produced attribute is not equal to <computeroutput>expected_</computeroutput>. <computeroutput>Radix</computeroutput> must be one of <computeroutput>2</computeroutput>, <computeroutput>8</computeroutput>, <computeroutput>10</computeroutput>, or <computeroutput>16</computeroutput>. </para></description></struct><struct name="lexeme_parser"><template>
      <template-type-parameter name="Parser"/>
    </template><description><para>Applies the given parser <computeroutput>p</computeroutput> of type <computeroutput>Parser</computeroutput>, disabling the current skipper in use, if any. The parse succeeds iff <computeroutput>p</computeroutput> succeeds. The attribute produced is the type of attribute produced by <computeroutput>Parser</computeroutput>. </para></description></struct><struct name="no_case_parser"><template>
      <template-type-parameter name="Parser"/>
    </template><description><para>Applies the given parser <computeroutput>p</computeroutput> of type <computeroutput>Parser</computeroutput>, enabling case-insensitive matching, based on Unicode case folding. The parse succeeds iff <computeroutput>p</computeroutput> succeeds. The attribute produced is the type of attribute produced by <computeroutput>Parser</computeroutput>. </para></description></struct><struct name="omit_parser"><template>
      <template-type-parameter name="Parser"/>
    </template><description><para>Applies the given parser <computeroutput>p</computeroutput> of type <computeroutput>Parser</computeroutput>. This parser produces no attribute, and suppresses the production of any attributes that would otherwise be produced by <computeroutput>p</computeroutput>. The parse succeeds iff <computeroutput>p</computeroutput> succeeds. </para></description></struct><struct name="raw_parser"><template>
      <template-type-parameter name="Parser"/>
    </template><description><para>Applies the given parser <computeroutput>p</computeroutput> of type <computeroutput>Parser</computeroutput>; regardless of the attribute produced by <computeroutput>Parser</computeroutput>, this parser's attribute is equivalent to <computeroutput>_where(ctx)</computeroutput> within a semantic action on <computeroutput>p</computeroutput>. The parse succeeds iff <computeroutput>p</computeroutput> succeeds. </para></description></struct><struct name="repeat_parser"><template>
      <template-type-parameter name="Parser"/>
      <template-type-parameter name="DelimiterParser"><default><classname alt="boost::parser::detail::nope">detail::nope</classname></default></template-type-parameter>
      <template-type-parameter name="MinType"><default><classname alt="boost::parser::parse_error">int64_t</classname></default></template-type-parameter>
      <template-type-parameter name="MaxType"><default><classname alt="boost::parser::parse_error">int64_t</classname></default></template-type-parameter>
    </template><description><para>Repeats the application of another parser <computeroutput>p</computeroutput> of type <computeroutput>Parser</computeroutput>, optionally applying another parser <computeroutput>d</computeroutput> of type <computeroutput>DelimiterParser</computeroutput> in between each pair of applications of <computeroutput>p</computeroutput>. The parse succeeds if <computeroutput>p</computeroutput> succeeds at least the minumum number of times, and <computeroutput>d</computeroutput> succeeds each time it is applied. The attribute produced is a sequence of the type of attribute produced by <computeroutput>Parser</computeroutput>. </para></description></struct><struct name="rule"><template>
      <template-type-parameter name="TagType"/>
      <template-type-parameter name="Attribute"><default>no_attribute</default></template-type-parameter>
      <template-type-parameter name="LocalState"><default>no_local_state</default></template-type-parameter>
      <template-type-parameter name="ParamsTuple"><default>no_params</default></template-type-parameter>
    </template><description><para>A type used to declare named parsing rules. The <computeroutput>TagType</computeroutput> template parameter is used to associate a particular <computeroutput>rule</computeroutput> with the <computeroutput><classname alt="boost::parser::rule_parser">rule_parser</classname></computeroutput> used during parsing. </para></description></struct><struct name="rule_parser"><template>
      <template-nontype-parameter name="CanUseCallbacks"><type><classname>bool</classname></type></template-nontype-parameter>
      <template-type-parameter name="TagType"/>
      <template-type-parameter name="Attribute"/>
      <template-type-parameter name="LocalState"/>
      <template-type-parameter name="ParamsTuple"/>
    </template><description><para>Applies another parser <computeroutput>p</computeroutput>, associated with this parser via <computeroutput>TagType</computeroutput>. The attribute produced is <computeroutput>Attribute</computeroutput>. Both a default-constructed object of type <computeroutput>LocalState</computeroutput>, and a default-constructed object of type <computeroutput>ParamsTuple</computeroutput>, are added to the parse context before the associated parser is applied. The parse succeeds iff <computeroutput>p</computeroutput> succeeds. If <computeroutput>CanUseCallbacks</computeroutput> is <computeroutput>true</computeroutput>, and if this parser is used within a call to <computeroutput>callback_parse()</computeroutput>, the attribute is produced via callback; otherwise, the attribute is produced as normal (as a return value, or as an out-param). The rule may be constructed with user-friendly diagnostic text that will appear if the top-level parse is executed with <computeroutput>trace_mode == boost::parser::trace::on</computeroutput>. </para></description></struct><struct name="seq_parser"><template>
      <template-type-parameter name="ParserTuple"/>
      <template-type-parameter name="BacktrackingTuple"/>
      <template-type-parameter name="CombiningGroups"/>
    </template><description><para>Applies each parser in <computeroutput>ParserTuple</computeroutput>, in order. The parse succeeds iff all of the sub-parsers succeed. The attribute produced is a <computeroutput>std::tuple</computeroutput> over the types of attribute produced by the parsers in <computeroutput>ParserTuple</computeroutput>. The BacktrackingTuple template parameter is a <computeroutput>parser::tuple</computeroutput> of <computeroutput>std::bool_constant</computeroutput> values. The <computeroutput>i</computeroutput>th such value indicates whether backtracking is allowed if the <computeroutput>i</computeroutput>th parser fails. </para></description></struct><struct name="skip_parser"><template>
      <template-type-parameter name="Parser"/>
      <template-type-parameter name="SkipParser"><default><classname alt="boost::parser::detail::nope">detail::nope</classname></default></template-type-parameter>
    </template><description><para>Applies the given parser <computeroutput>p</computeroutput> of type <computeroutput>Parser</computeroutput>, using a parser of type <computeroutput>SkipParser</computeroutput> as the skipper. The parse succeeds iff <computeroutput>p</computeroutput> succeeds. The attribute produced is the type of attribute produced by <computeroutput>Parser</computeroutput>. </para></description></struct><struct name="sorted_t"><description><para>A tag type that can be passed as the first parameter to <computeroutput>char_()</computeroutput> when the second parameter is a sorted, random access sequence that can be matched using a binary search. </para></description></struct><struct name="string_parser"><template>
      <template-type-parameter name="StrIter"/>
      <template-type-parameter name="StrSentinel"/>
    </template><description><para>Matches a particular string, delimited by an iterator sentinel pair; produces no attribute. </para></description></struct><struct name="string_view_parser"><template>
      <template-type-parameter name="Parser"/>
    </template><description><para>Applies the given parser <computeroutput>p</computeroutput> of type <computeroutput>Parser</computeroutput>. Regardless of the attribute produced by <computeroutput>Parser</computeroutput>, this parser's attribute is equivalent to <computeroutput>std::basic_string_view&lt;char_type&gt;</computeroutput> within a semantic action on <computeroutput>p</computeroutput>, where <computeroutput>char_type</computeroutput> is the type of character in the sequence being parsed. If the parsed range is transcoded, <computeroutput>char_type</computeroutput> will be the type being transcoded from. If the underlying range of <computeroutput>char_type</computeroutput> is non-contiguous, code using <computeroutput><classname alt="boost::parser::string_view_parser">string_view_parser</classname></computeroutput> is ill-formed. The parse succeeds iff <computeroutput>p</computeroutput> succeeds. This parser is only available in C++20 and later. </para></description></struct><struct name="switch_parser"><template>
      <template-type-parameter name="SwitchValue"/>
      <template-type-parameter name="OrParser"><default><classname alt="boost::parser::detail::nope">detail::nope</classname></default></template-type-parameter>
    </template><description><para>Applies at most one of the parsers in <computeroutput>OrParser</computeroutput>. If <computeroutput>switch_value_</computeroutput> matches one or more of the values in the parsers in <computeroutput>OrParser</computeroutput>, the first such parser is applied, and the success or failure and attribute of the parse are those of the applied parser. Otherwise, the parse fails. </para></description></struct><struct name="symbol_parser"><template>
      <template-type-parameter name="T"/>
    </template><description><para>Matches one of a set S of possible inputs, each of which is associated with an attribute value of type <computeroutput>T</computeroutput>, forming a symbol table. New elements and their associated attributes may be added to or removed from S dynamically, during parsing; any such changes are reverted at the end of parsing. The parse succeeds iff an element of S is matched. <para><emphasis role="bold">See Also:</emphasis><para><computeroutput><classname alt="boost::parser::symbols">symbols</classname></computeroutput> </para>
</para>
</para></description></struct><struct name="transform_parser"><template>
      <template-type-parameter name="Parser"/>
      <template-type-parameter name="F"/>
    </template><description><para>Applies the given parser <computeroutput>p</computeroutput> of type <computeroutput>Parser</computeroutput>. The attribute produced by <computeroutput>p</computeroutput> is passed to the fiven invocable <computeroutput>f</computeroutput> of type <computeroutput>F</computeroutput>. <computeroutput>f</computeroutput> will only be invoked if <computeroutput>p</computeroutput> succeeds and sttributes are currently being generated. The parse succeeds iff <computeroutput>p</computeroutput> succeeds. The attribute produced is the the result of the call to <computeroutput>f</computeroutput>. </para></description></struct><struct name="uint_parser"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Radix"><type><classname>int</classname></type><default>10</default></template-nontype-parameter>
      <template-nontype-parameter name="MinDigits"><type><classname>int</classname></type><default>1</default></template-nontype-parameter>
      <template-nontype-parameter name="MaxDigits"><type><classname>int</classname></type><default>-1</default></template-nontype-parameter>
      <template-type-parameter name="Expected"><default><classname alt="boost::parser::detail::nope">detail::nope</classname></default></template-type-parameter>
    </template><description><para>Matches an unsigned number of radix <computeroutput>Radix</computeroutput>, of at least <computeroutput>MinDigits</computeroutput> and at most <computeroutput>MaxDigits</computeroutput>, producing an attribute of type <computeroutput>T</computeroutput>. Fails on any other input. The parse will also fail if <computeroutput>Expected</computeroutput> is anything but <computeroutput><classname alt="boost::parser::detail::nope">detail::nope</classname></computeroutput> (which it is by default), and the produced attribute is not equal to <computeroutput>expected_</computeroutput>. <computeroutput>Radix</computeroutput> must be in <computeroutput>[2, 36]</computeroutput>. </para></description></struct><struct name="ws_parser"><template>
      <template-nontype-parameter name="NewlinesOnly"><type><classname>bool</classname></type></template-nontype-parameter>
      <template-nontype-parameter name="NoNewlines"><type><classname>bool</classname></type></template-nontype-parameter>
    </template><description><para>Matches an end-of-line (<computeroutput>NewlinesOnly == true</computeroutput>), whitespace (<computeroutput>NewlinesOnly == false</computeroutput>), or (<computeroutput>NoNewlines == true</computeroutput>) blank (whitespace but not newline) code point, based on the Unicode definitions of each (also matches the two code points <computeroutput>"\r\n"</computeroutput>). Produces no attribute. </para></description></struct><typedef name="null_sentinel_t"><description><para>A sentinel type that compares equal to a pointer to a character value type, iff the pointer is null. </para></description><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="attribute_t"><description><para>An alias for <computeroutput>typename attribute&lt;R, Parser&gt;::type</computeroutput>. </para></description><type><classname>typename</classname> <classname>attribute</classname>&lt; <classname>R</classname>, <classname>Parser</classname> &gt;::type</type></typedef>
<typedef name="no_attribute"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="no_local_state"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="no_params"><type><emphasis>unspecified</emphasis></type></typedef>
<data-member name="enable_optional"><type><classname>constexpr</classname> <classname>bool</classname></type><description><para>A variable template that indicates that type <computeroutput>T</computeroutput> is an optional-like type. </para></description></data-member>
<data-member name="enable_variant"><type><classname>constexpr</classname> <classname>bool</classname></type><description><para>A variable template that indicates that type <computeroutput>T</computeroutput> is an variant-like type. </para></description></data-member>
<data-member name="sorted"><type><classname>constexpr</classname> <classname>sorted_t</classname></type></data-member>






















<function name="null_term"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-type-parameter name="CharT"/>
        </template><parameter name="ptr"><paramtype><classname>CharT</classname> *</paramtype></parameter><description><para>Produces a <computeroutput>subrange</computeroutput> comprising the given pointer and <computeroutput>null_sentinel</computeroutput>. This should be used to make Null-Terminated Byte Strings ("NTBSs") compatible with ranges. </para></description></function>
<function name="_val"><type><classname>decltype</classname>(<classname>auto</classname>)</type><parameter name="context"><paramtype><classname>Context</classname> <classname>const</classname> &amp;</paramtype></parameter><description><para>Returns a reference to the attribute(s) (i.e. return value) of the bottommost parser; multiple attributes will be stored within a <computeroutput>parser::tuple</computeroutput>. You may write to this value in a semantic action to control what attribute value(s) the associated parser produces. Returns <computeroutput>none</computeroutput> if the bottommost parser does produce an attribute. </para></description></function>
<function name="_attr"><type><classname>decltype</classname>(<classname>auto</classname>)</type><template>
          <template-type-parameter name="Context"/>
        </template><parameter name="context"><paramtype><classname>Context</classname> <classname>const</classname> &amp;</paramtype></parameter><description><para>Returns a reference to the attribute or attributes already produced by the bottommost parser; multiple attributes will be stored within a <computeroutput>parser::tuple</computeroutput>. Returns <computeroutput>none</computeroutput> if the bottommost parser does produce an attribute. </para></description></function>
<function name="_where"><type><classname>decltype</classname>(<classname>auto</classname>)</type><template>
          <template-type-parameter name="Context"/>
        </template><parameter name="context"><paramtype><classname>Context</classname> <classname>const</classname> &amp;</paramtype></parameter><description><para>Returns a <computeroutput>subrange</computeroutput> that describes the matched range of the bottommost parser. </para></description></function>
<function name="_begin"><type><classname>decltype</classname>(<classname>auto</classname>)</type><template>
          <template-type-parameter name="Context"/>
        </template><parameter name="context"><paramtype><classname>Context</classname> <classname>const</classname> &amp;</paramtype></parameter><description><para>Returns an iterator to the beginning of the entire sequence being parsed. The effect of calling this within a semantic action associated with a skip-parser is undefined </para></description></function>
<function name="_end"><type><classname>decltype</classname>(<classname>auto</classname>)</type><template>
          <template-type-parameter name="Context"/>
        </template><parameter name="context"><paramtype><classname>Context</classname> <classname>const</classname> &amp;</paramtype></parameter><description><para>Returns an iterator to the end of the entire sequence being parsed. </para></description></function>
<function name="_pass"><type><classname>decltype</classname>(<classname>auto</classname>)</type><template>
          <template-type-parameter name="Context"/>
        </template><parameter name="context"><paramtype><classname>Context</classname> <classname>const</classname> &amp;</paramtype></parameter><description><para>Returns a reference to a <computeroutput>bool</computeroutput> that represents the success or failure of the bottommost parser. You can assign <computeroutput>false</computeroutput> to this within a semantic action to force a parser to fail its parse. </para></description></function>
<function name="_locals"><type><classname>decltype</classname>(<classname>auto</classname>)</type><template>
          <template-type-parameter name="Context"/>
        </template><parameter name="context"><paramtype><classname>Context</classname> <classname>const</classname> &amp;</paramtype></parameter><description><para>Returns a reference to one or more local values that the bottommost rule is declared to have; multiple values will be stored within a <computeroutput>parser::tuple</computeroutput>. Returns <computeroutput>none</computeroutput> if there is no bottommost rule, or if that rule has no locals. </para></description></function>
<function name="_params"><type><classname>decltype</classname>(<classname>auto</classname>)</type><template>
          <template-type-parameter name="Context"/>
        </template><parameter name="context"><paramtype><classname>Context</classname> <classname>const</classname> &amp;</paramtype></parameter><description><para>Returns a reference to one or more parameters passed to the bottommost rule <computeroutput>r</computeroutput>, by using <computeroutput>r</computeroutput> as <computeroutput>r.with(param0, param1, ... paramN)</computeroutput>; multiple values will be stored within a <computeroutput>parser::tuple</computeroutput>. Returns <computeroutput>none</computeroutput> if there is no bottommost rule, or if that rule was not given any parameters. </para></description></function>
<function name="_globals"><type><classname>decltype</classname>(<classname>auto</classname>)</type><template>
          <template-type-parameter name="Context"/>
        </template><parameter name="context"><paramtype><classname>Context</classname> <classname>const</classname> &amp;</paramtype></parameter><description><para>Returns a reference to the globals object associated with the top-level parser. Returns <computeroutput>none</computeroutput> if there is no associated globals object. </para></description></function>
<function name="_error_handler"><type><classname>decltype</classname>(<classname>auto</classname>)</type><template>
          <template-type-parameter name="Context"/>
        </template><parameter name="context"><paramtype><classname>Context</classname> <classname>const</classname> &amp;</paramtype></parameter><description><para>Returns a reference to the error handler object associated with the top-level parser. Returns <computeroutput>none</computeroutput> if there is no associated error handler. </para></description></function>
<function name="_report_error"><type><classname>void</classname></type><template>
          <template-nontype-parameter name="I"><type>std::forward_iterator</type></template-nontype-parameter>
          <template-type-parameter name="Context"/>
        </template><parameter name="context"><paramtype><classname>Context</classname> <classname>const</classname> &amp;</paramtype></parameter><parameter name="message"><paramtype>std::string_view</paramtype></parameter><parameter name="location"><paramtype>I</paramtype></parameter><description><para>Report that the error described in <computeroutput>message</computeroutput> occurred at <computeroutput>location</computeroutput>, using the context's error handler. </para></description></function>
<function name="_report_error"><type><classname>void</classname></type><template>
          <template-type-parameter name="Context"/>
        </template><parameter name="context"><paramtype><classname>Context</classname> <classname>const</classname> &amp;</paramtype></parameter><parameter name="message"><paramtype>std::string_view</paramtype></parameter><description><para>Report that the error described in <computeroutput>message</computeroutput> occurred at <computeroutput>_where(context).begin()</computeroutput>, using the context's error handler. </para></description></function>
<function name="_report_warning"><type><classname>void</classname></type><template>
          <template-nontype-parameter name="I"><type>std::forward_iterator</type></template-nontype-parameter>
          <template-type-parameter name="Context"/>
        </template><parameter name="context"><paramtype><classname>Context</classname> <classname>const</classname> &amp;</paramtype></parameter><parameter name="message"><paramtype>std::string_view</paramtype></parameter><parameter name="location"><paramtype>I</paramtype></parameter><description><para>Report that the warning described in <computeroutput>message</computeroutput> occurred at <computeroutput>location</computeroutput>, using the context's error handler. </para></description></function>
<function name="_report_warning"><type><classname>void</classname></type><template>
          <template-type-parameter name="Context"/>
        </template><parameter name="context"><paramtype><classname>Context</classname> <classname>const</classname> &amp;</paramtype></parameter><parameter name="message"><paramtype>std::string_view</paramtype></parameter><description><para>Report that the warning described in <computeroutput>message</computeroutput> occurred at <computeroutput>_where(context).begin()</computeroutput>, using the context's error handler. </para></description></function>














































</namespace>
</namespace>
</header>
<header name="boost/parser/replace.hpp">
<namespace name="boost">
<namespace name="parser">
<struct name="replace_view"><template>
      <template-nontype-parameter name="V"><type>std::ranges::viewable_range</type></template-nontype-parameter>
      <template-nontype-parameter name="ReplacementV"><type>std::ranges::viewable_range</type></template-nontype-parameter>
      <template-type-parameter name="Parser"/>
      <template-type-parameter name="GlobalState"/>
      <template-type-parameter name="ErrorHandler"/>
      <template-type-parameter name="SkipParser"/>
    </template><description><para>Produces a range of subranges of a given range <computeroutput>base</computeroutput>. Each subrange is either a subrange of <computeroutput>base</computeroutput> that does not match the given parser <computeroutput>parser</computeroutput>, or is the given replacement for a match, <computeroutput>replacement</computeroutput>.</para><para>In addition to the template parameter constraints, <computeroutput>V</computeroutput> and <computeroutput>ReplacementV</computeroutput> must be ranges of <computeroutput>char</computeroutput>, or must have the same UTF format, and <computeroutput>V</computeroutput> and <computeroutput>ReplacementV</computeroutput> must meet the same compatibility requirements as described in <computeroutput>std::ranges::join_view</computeroutput>. </para></description><struct name="iterator"><template>
      <template-nontype-parameter name="Const"><type><classname>bool</classname></type></template-nontype-parameter>
    </template><typedef name="I"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="S"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="ref_t_iter"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="reference_type"><type>BOOST_PARSER_SUBRANGE&lt; ref_t_iter &gt;</type></typedef>
<typedef name="base_type"><type><emphasis>unspecified</emphasis></type></typedef>
<method-group name="public member functions">
<method name="operator++"><type><classname>constexpr</classname> <classname>iterator</classname> &amp;</type></method>
<method name="operator*" cv="const"><type><classname>constexpr</classname> reference_type</type></method>
</method-group>
<constructor cv="= default"/>
<constructor><parameter name="parent"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></constructor>
</struct><struct name="sentinel"><template>
      <template-nontype-parameter name="Const"><type><classname>bool</classname></type></template-nontype-parameter>
    </template></struct><method-group name="public member functions">
<method name="base" cv="const"><type><classname>constexpr</classname> V</type></method>
<method name="base"><type><classname>constexpr</classname> V</type></method>
<method name="replacement" cv="const"><type><classname>constexpr</classname> V</type></method>
<method name="replacement"><type><classname>constexpr</classname> V</type></method>
<method name="begin"><type><classname>constexpr</classname> <classname>auto</classname></type></method>
<method name="end"><type><classname>constexpr</classname> <classname>auto</classname></type></method>
<method name="begin" cv="const"><type><classname>constexpr</classname> <classname>auto</classname></type></method>
<method name="end" cv="const"><type><classname>constexpr</classname> <classname>auto</classname></type></method>
</method-group>
<constructor cv="= default"/>
<constructor><parameter name="base"><paramtype>V</paramtype></parameter><parameter name="parser"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="skip"><paramtype><classname>parser_interface</classname>&lt; <classname>SkipParser</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="replacement"><paramtype>ReplacementV</paramtype></parameter><parameter name="trace_mode"><paramtype>trace</paramtype><default>trace::off</default></parameter></constructor>
<constructor><parameter name="base"><paramtype>V</paramtype></parameter><parameter name="parser"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="replacement"><paramtype>ReplacementV</paramtype></parameter><parameter name="trace_mode"><paramtype>trace</paramtype><default>trace::off</default></parameter></constructor>
</struct><data-member name="replace"><type><emphasis>unspecified</emphasis></type><description><para>A range adaptor object ([range.adaptor.object]). Given subexpressions <computeroutput>E</computeroutput> and <computeroutput>P</computeroutput>, <computeroutput>Q</computeroutput>, <computeroutput>R</computeroutput>, and 'S', each of the expressions <computeroutput>replace(E,
P)</computeroutput>, <computeroutput>replace(E, P, Q)</computeroutput>. <computeroutput>replace(E, P, Q, R)</computeroutput>, and <computeroutput>replace(E, P, Q,
R, S)</computeroutput> are expression-equivalent to <computeroutput>replace_view(E, P)</computeroutput>, <computeroutput>replace_view(E, P, Q)</computeroutput>, <computeroutput>replace_view(E, P, Q, R)</computeroutput>, <computeroutput>replace_view(E,
P, Q, R, S)</computeroutput>, respectively. </para></description></data-member>


















<function name="replace_view"><type/><template>
          <template-type-parameter name="V"/>
          <template-type-parameter name="ReplacementV"/>
          <template-type-parameter name="Parser"/>
          <template-type-parameter name="GlobalState"/>
          <template-type-parameter name="ErrorHandler"/>
          <template-type-parameter name="SkipParser"/>
        </template><parameter name=""><paramtype>V &amp;&amp;</paramtype></parameter><parameter name=""><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt;</paramtype></parameter><parameter name=""><paramtype><classname>parser_interface</classname>&lt; <classname>SkipParser</classname> &gt;</paramtype></parameter><parameter name=""><paramtype>ReplacementV &amp;&amp;</paramtype></parameter><parameter name=""><paramtype>trace</paramtype></parameter></function>
<function name="replace_view"><type/><template>
          <template-type-parameter name="V"/>
          <template-type-parameter name="ReplacementV"/>
          <template-type-parameter name="Parser"/>
          <template-type-parameter name="GlobalState"/>
          <template-type-parameter name="ErrorHandler"/>
          <template-type-parameter name="SkipParser"/>
        </template><parameter name=""><paramtype>V &amp;&amp;</paramtype></parameter><parameter name=""><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt;</paramtype></parameter><parameter name=""><paramtype><classname>parser_interface</classname>&lt; <classname>SkipParser</classname> &gt;</paramtype></parameter><parameter name=""><paramtype>ReplacementV &amp;&amp;</paramtype></parameter></function>
<function name="replace_view"><type/><template>
          <template-type-parameter name="V"/>
          <template-type-parameter name="ReplacementV"/>
          <template-type-parameter name="Parser"/>
          <template-type-parameter name="GlobalState"/>
          <template-type-parameter name="ErrorHandler"/>
        </template><parameter name=""><paramtype>V &amp;&amp;</paramtype></parameter><parameter name=""><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt;</paramtype></parameter><parameter name=""><paramtype>ReplacementV &amp;&amp;</paramtype></parameter><parameter name=""><paramtype>trace</paramtype></parameter></function>
<function name="replace_view"><type/><template>
          <template-type-parameter name="V"/>
          <template-type-parameter name="ReplacementV"/>
          <template-type-parameter name="Parser"/>
          <template-type-parameter name="GlobalState"/>
          <template-type-parameter name="ErrorHandler"/>
        </template><parameter name=""><paramtype>V &amp;&amp;</paramtype></parameter><parameter name=""><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt;</paramtype></parameter><parameter name=""><paramtype>ReplacementV &amp;&amp;</paramtype></parameter></function>





























































</namespace>
</namespace>
</header>
<header name="boost/parser/search.hpp">
<namespace name="boost">
<namespace name="parser">
<struct name="search_all_view"><template>
      <template-nontype-parameter name="V"><type>std::ranges::viewable_range</type></template-nontype-parameter>
      <template-type-parameter name="Parser"/>
      <template-type-parameter name="GlobalState"/>
      <template-type-parameter name="ErrorHandler"/>
      <template-type-parameter name="SkipParser"/>
    </template><description><para>Produces a sequence of subranges of the underlying sequence of type <computeroutput>V</computeroutput>. Each subrange is a nonoverlapping match of the given parser, using a skip-parser if provided. </para></description><struct name="iterator"><template>
      <template-nontype-parameter name="Const"><type><classname>bool</classname></type></template-nontype-parameter>
    </template><typedef name="I"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="S"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="base_type"><type><emphasis>unspecified</emphasis></type></typedef>
<method-group name="public member functions">
<method name="operator++"><type><classname>constexpr</classname> <classname>iterator</classname> &amp;</type></method>
<method name="operator*" cv="const"><type><classname>constexpr</classname> BOOST_PARSER_SUBRANGE&lt; I &gt;</type></method>
</method-group>
<constructor cv="= default"/>
<constructor><parameter name="parent"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></constructor>
</struct><struct name="sentinel"><template>
      <template-nontype-parameter name="Const"><type><classname>bool</classname></type></template-nontype-parameter>
    </template></struct><method-group name="public member functions">
<method name="base" cv="const"><type><classname>constexpr</classname> V</type></method>
<method name="base"><type><classname>constexpr</classname> V</type></method>
<method name="begin"><type><classname>constexpr</classname> <classname>auto</classname></type></method>
<method name="end"><type><classname>constexpr</classname> <classname>auto</classname></type></method>
<method name="begin" cv="const"><type><classname>constexpr</classname> <classname>auto</classname></type></method>
<method name="end" cv="const"><type><classname>constexpr</classname> <classname>auto</classname></type></method>
</method-group>
<constructor cv="= default"/>
<constructor><parameter name="base"><paramtype>V</paramtype></parameter><parameter name="parser"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="skip"><paramtype><classname>parser_interface</classname>&lt; <classname>SkipParser</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="trace_mode"><paramtype>trace</paramtype><default>trace::off</default></parameter></constructor>
<constructor><parameter name="base"><paramtype>V</paramtype></parameter><parameter name="parser"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="trace_mode"><paramtype>trace</paramtype><default>trace::off</default></parameter></constructor>
</struct><data-member name="search_all"><type><emphasis>unspecified</emphasis></type><description><para>A range adaptor object ([range.adaptor.object]). Given subexpressions <computeroutput>E</computeroutput> and <computeroutput>P</computeroutput>, <computeroutput>Q</computeroutput>, and <computeroutput>R</computeroutput>, each of the expressions <computeroutput>search_all(E, P)</computeroutput>, <computeroutput>search_all(E, P, Q)</computeroutput>, and <computeroutput>search_all(E, P, Q, R)</computeroutput> are expression-equivalent to <computeroutput>search_all_view(E, P)</computeroutput>, <computeroutput>search_all_view(E,
P, Q)</computeroutput>, and <computeroutput>search_all_view(E, P, Q, R)</computeroutput>, respectively. </para></description></data-member>










<function name="search"><type><classname>auto</classname></type><template>
          <template-nontype-parameter name="R"><type>parsable_range</type></template-nontype-parameter>
          <template-type-parameter name="Parser"/>
          <template-type-parameter name="GlobalState"/>
          <template-type-parameter name="ErrorHandler"/>
          <template-type-parameter name="SkipParser"/>
        </template><parameter name="r"><paramtype><classname>R</classname> &amp;&amp;</paramtype></parameter><parameter name="parser"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="skip"><paramtype><classname>parser_interface</classname>&lt; <classname>SkipParser</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="trace_mode"><paramtype>trace</paramtype><default>trace::off</default></parameter><description><para>Returns a subrange to the first match for parser <computeroutput>parser</computeroutput> in <computeroutput>r</computeroutput>, using skip-parser <computeroutput>skip</computeroutput>. This function has a similar interface and semantics to <computeroutput>std::ranges::search()</computeroutput>. Returns <computeroutput>std::ranges::dangling</computeroutput> in C++20 and later if <computeroutput>r</computeroutput> is a non-borrowable rvalue. </para></description></function>
<function name="search"><type><classname>auto</classname></type><template>
          <template-nontype-parameter name="I"><type>parsable_iter</type></template-nontype-parameter>
          <template-nontype-parameter name="S"><type>std::sentinel_for&lt; I &gt;</type></template-nontype-parameter>
          <template-type-parameter name="Parser"/>
          <template-type-parameter name="SkipParser"/>
          <template-type-parameter name="GlobalState"/>
          <template-nontype-parameter name="ErrorHandler"><type>error_handler&lt; I, S, GlobalState &gt;</type></template-nontype-parameter>
        </template><parameter name="first"><paramtype>I</paramtype></parameter><parameter name="last"><paramtype>S</paramtype></parameter><parameter name="parser"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="skip"><paramtype><classname>parser_interface</classname>&lt; <classname>SkipParser</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="trace_mode"><paramtype>trace</paramtype><default>trace::off</default></parameter><description><para>Returns a subrange to the first match for parser <computeroutput>parser</computeroutput> in <computeroutput>[first, last)</computeroutput>, using skip-parser <computeroutput>skip</computeroutput>. This function has a similar interface and semantics to <computeroutput>std::ranges::search()</computeroutput>. </para></description></function>
<function name="search"><type><classname>auto</classname></type><template>
          <template-nontype-parameter name="R"><type>parsable_range</type></template-nontype-parameter>
          <template-type-parameter name="Parser"/>
          <template-type-parameter name="GlobalState"/>
          <template-type-parameter name="ErrorHandler"/>
        </template><parameter name="r"><paramtype><classname>R</classname> &amp;&amp;</paramtype></parameter><parameter name="parser"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="trace_mode"><paramtype>trace</paramtype><default>trace::off</default></parameter><description><para>Returns a subrange to the first match for parser <computeroutput>parser</computeroutput> in <computeroutput>r</computeroutput>. This function has a similar interface and semantics to <computeroutput>std::ranges::search()</computeroutput>. Returns <computeroutput>std::ranges::dangling</computeroutput> in C++20 and later if <computeroutput>r</computeroutput> is a non-borrowable rvalue. </para></description></function>
<function name="search"><type><classname>auto</classname></type><template>
          <template-nontype-parameter name="I"><type>parsable_iter</type></template-nontype-parameter>
          <template-nontype-parameter name="S"><type>std::sentinel_for&lt; I &gt;</type></template-nontype-parameter>
          <template-type-parameter name="Parser"/>
          <template-type-parameter name="GlobalState"/>
          <template-nontype-parameter name="ErrorHandler"><type>error_handler&lt; I, S, GlobalState &gt;</type></template-nontype-parameter>
        </template><parameter name="first"><paramtype>I</paramtype></parameter><parameter name="last"><paramtype>S</paramtype></parameter><parameter name="parser"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="trace_mode"><paramtype>trace</paramtype><default>trace::off</default></parameter><description><para>Returns a subrange to the first match for parser <computeroutput>parser</computeroutput> in <computeroutput>[first, last)</computeroutput>. This function has a similar interface and semantics to <computeroutput>std::ranges::search()</computeroutput>. </para></description></function>
<function name="search_all_view"><type/><template>
          <template-type-parameter name="V"/>
          <template-type-parameter name="Parser"/>
          <template-type-parameter name="GlobalState"/>
          <template-type-parameter name="ErrorHandler"/>
          <template-type-parameter name="SkipParser"/>
        </template><parameter name=""><paramtype>V &amp;&amp;</paramtype></parameter><parameter name=""><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt;</paramtype></parameter><parameter name=""><paramtype><classname>parser_interface</classname>&lt; <classname>SkipParser</classname> &gt;</paramtype></parameter><parameter name=""><paramtype>trace</paramtype></parameter></function>
<function name="search_all_view"><type/><template>
          <template-type-parameter name="V"/>
          <template-type-parameter name="Parser"/>
          <template-type-parameter name="GlobalState"/>
          <template-type-parameter name="ErrorHandler"/>
          <template-type-parameter name="SkipParser"/>
        </template><parameter name=""><paramtype>V &amp;&amp;</paramtype></parameter><parameter name=""><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt;</paramtype></parameter><parameter name=""><paramtype><classname>parser_interface</classname>&lt; <classname>SkipParser</classname> &gt;</paramtype></parameter></function>
<function name="search_all_view"><type/><template>
          <template-type-parameter name="V"/>
          <template-type-parameter name="Parser"/>
          <template-type-parameter name="GlobalState"/>
          <template-type-parameter name="ErrorHandler"/>
        </template><parameter name=""><paramtype>V &amp;&amp;</paramtype></parameter><parameter name=""><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt;</paramtype></parameter><parameter name=""><paramtype>trace</paramtype></parameter></function>
<function name="search_all_view"><type/><template>
          <template-type-parameter name="V"/>
          <template-type-parameter name="Parser"/>
          <template-type-parameter name="GlobalState"/>
          <template-type-parameter name="ErrorHandler"/>
        </template><parameter name=""><paramtype>V &amp;&amp;</paramtype></parameter><parameter name=""><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt;</paramtype></parameter></function>

































































</namespace>
</namespace>
</header>
<header name="boost/parser/split.hpp">
<namespace name="boost">
<namespace name="parser">
<struct name="split_view"><template>
      <template-nontype-parameter name="V"><type>std::ranges::viewable_range</type></template-nontype-parameter>
      <template-type-parameter name="Parser"/>
      <template-type-parameter name="GlobalState"/>
      <template-type-parameter name="ErrorHandler"/>
      <template-type-parameter name="SkipParser"/>
    </template><description><para>Produces a sequence of subranges of the underlying sequence of type <computeroutput>V</computeroutput>. the underlying sequence is split into subranges delimited by matches of the given parser, possibly using a given skip-parser. </para></description><struct name="iterator"><template>
      <template-nontype-parameter name="Const"><type><classname>bool</classname></type></template-nontype-parameter>
    </template><typedef name="I"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="S"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="base_type"><type><emphasis>unspecified</emphasis></type></typedef>
<method-group name="public member functions">
<method name="operator++"><type><classname>constexpr</classname> <classname>iterator</classname> &amp;</type></method>
<method name="operator*" cv="const"><type><classname>constexpr</classname> BOOST_PARSER_SUBRANGE&lt; I &gt;</type></method>
</method-group>
<constructor cv="= default"/>
<constructor><parameter name="parent"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></constructor>
</struct><struct name="sentinel"><template>
      <template-nontype-parameter name="Const"><type><classname>bool</classname></type></template-nontype-parameter>
    </template></struct><method-group name="public member functions">
<method name="base" cv="const"><type><classname>constexpr</classname> V</type></method>
<method name="base"><type><classname>constexpr</classname> V</type></method>
<method name="begin"><type><classname>constexpr</classname> <classname>auto</classname></type></method>
<method name="end"><type><classname>constexpr</classname> <classname>auto</classname></type></method>
<method name="begin" cv="const"><type><classname>constexpr</classname> <classname>auto</classname></type></method>
<method name="end" cv="const"><type><classname>constexpr</classname> <classname>auto</classname></type></method>
</method-group>
<constructor cv="= default"/>
<constructor><parameter name="base"><paramtype>V</paramtype></parameter><parameter name="parser"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="skip"><paramtype><classname>parser_interface</classname>&lt; <classname>SkipParser</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="trace_mode"><paramtype>trace</paramtype><default>trace::off</default></parameter></constructor>
<constructor><parameter name="base"><paramtype>V</paramtype></parameter><parameter name="parser"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="trace_mode"><paramtype>trace</paramtype><default>trace::off</default></parameter></constructor>
</struct><data-member name="split"><type><emphasis>unspecified</emphasis></type><description><para>A range adaptor object ([range.adaptor.object]). Given subexpressions <computeroutput>E</computeroutput> and <computeroutput>P</computeroutput>, <computeroutput>Q</computeroutput>, and <computeroutput>R</computeroutput>, each of the expressions <computeroutput>split(E, P)</computeroutput>, <computeroutput>split(E, P, Q)</computeroutput>, and <computeroutput>split(E, P, Q, R)</computeroutput> are expression-equivalent to <computeroutput>split_view(E, P)</computeroutput>, <computeroutput>split_view(E,
P, Q)</computeroutput>, and <computeroutput>split_view(E, P, Q, R)</computeroutput>, respectively. </para></description></data-member>






<function name="split_view"><type/><template>
          <template-type-parameter name="V"/>
          <template-type-parameter name="Parser"/>
          <template-type-parameter name="GlobalState"/>
          <template-type-parameter name="ErrorHandler"/>
          <template-type-parameter name="SkipParser"/>
        </template><parameter name=""><paramtype>V &amp;&amp;</paramtype></parameter><parameter name=""><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt;</paramtype></parameter><parameter name=""><paramtype><classname>parser_interface</classname>&lt; <classname>SkipParser</classname> &gt;</paramtype></parameter><parameter name=""><paramtype>trace</paramtype></parameter></function>
<function name="split_view"><type/><template>
          <template-type-parameter name="V"/>
          <template-type-parameter name="Parser"/>
          <template-type-parameter name="GlobalState"/>
          <template-type-parameter name="ErrorHandler"/>
          <template-type-parameter name="SkipParser"/>
        </template><parameter name=""><paramtype>V &amp;&amp;</paramtype></parameter><parameter name=""><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt;</paramtype></parameter><parameter name=""><paramtype><classname>parser_interface</classname>&lt; <classname>SkipParser</classname> &gt;</paramtype></parameter></function>
<function name="split_view"><type/><template>
          <template-type-parameter name="V"/>
          <template-type-parameter name="Parser"/>
          <template-type-parameter name="GlobalState"/>
          <template-type-parameter name="ErrorHandler"/>
        </template><parameter name=""><paramtype>V &amp;&amp;</paramtype></parameter><parameter name=""><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt;</paramtype></parameter><parameter name=""><paramtype>trace</paramtype></parameter></function>
<function name="split_view"><type/><template>
          <template-type-parameter name="V"/>
          <template-type-parameter name="Parser"/>
          <template-type-parameter name="GlobalState"/>
          <template-type-parameter name="ErrorHandler"/>
        </template><parameter name=""><paramtype>V &amp;&amp;</paramtype></parameter><parameter name=""><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt;</paramtype></parameter></function>









































































</namespace>
</namespace>
</header>
<header name="boost/parser/subrange.hpp">
<namespace name="boost">
<namespace name="parser">
<struct name="subrange"><template>
      <template-nontype-parameter name="I"><type>std::forward_iterator</type></template-nontype-parameter>
      <template-nontype-parameter name="S"><type>std::sentinel_for&lt; I &gt;</type><default>I</default></template-nontype-parameter>
    </template><description><para>A simple view type used throughout the rest of the library in C++17 builds; similar to <computeroutput>std::ranges::subrange</computeroutput>. </para></description><method-group name="public member functions">
<method name="begin" cv="const"><type><classname>constexpr</classname> I</type></method>
<method name="end" cv="const"><type><classname>constexpr</classname> S</type></method>
<method name="next" cv="const"><type><classname>constexpr</classname> <classname>subrange</classname></type><parameter name="n"><paramtype>std::ptrdiff_t</paramtype><default>1</default></parameter></method>
<method name="prev" cv="const"><type><classname>constexpr</classname> <classname>subrange</classname></type><parameter name="n"><paramtype>std::ptrdiff_t</paramtype><default>1</default></parameter></method>
<method name="advance"><type><classname>constexpr</classname> <classname>subrange</classname> &amp;</type><parameter name="n"><paramtype>std::ptrdiff_t</paramtype></parameter></method>
<method name="operator subrange&lt; I2, S2 &gt;" cv="const"><type><classname>constexpr</classname></type><template>
          <template-type-parameter name="I2"/>
          <template-type-parameter name="S2"/>
          <template-type-parameter name="Enable"><default>std::enable_if_t&lt;                std::is_convertible&lt;I, <classname alt="boost::parser::parse_error">I2</classname>&gt;::value &amp;&amp;                std::is_convertible&lt;S, <classname alt="boost::parser::parse_error">S2</classname>&gt;::value&gt;</default></template-type-parameter>
        </template></method>
</method-group>
<constructor cv="= default"/>
<constructor><parameter name="first"><paramtype>I</paramtype></parameter><parameter name="last"><paramtype>S</paramtype></parameter></constructor>
<constructor specifiers="explicit"><template>
          <template-type-parameter name="R"/>
        </template><parameter name="r"><paramtype><classname>R</classname> <classname>const</classname> &amp;</paramtype></parameter></constructor>
</struct>




<function name="make_subrange"><type><classname>constexpr</classname> <classname>subrange</classname>&lt; I, S &gt;</type><template>
          <template-nontype-parameter name="I"><type>std::forward_iterator</type></template-nontype-parameter>
          <template-nontype-parameter name="S"><type>std::sentinel_for&lt; I &gt;</type><default>I</default></template-nontype-parameter>
        </template><parameter name="first"><paramtype>I</paramtype></parameter><parameter name="last"><paramtype>S</paramtype></parameter><description><para>Makes a <computeroutput>subrange&lt;I, S&gt;</computeroutput> from an <computeroutput>I</computeroutput> and an <computeroutput>S</computeroutput>. </para></description></function>













































































</namespace>
</namespace>
<namespace name="std">
<namespace name="ranges">
</namespace>
</namespace>
</header>
<header name="boost/parser/transcode_view.hpp">
<namespace name="boost">
<namespace name="parser">
<class name="utf16_view"><template>
      <template-nontype-parameter name="V"><type><emphasis>unspecified</emphasis></type><purpose><para>Constrained by <computeroutput>std::ranges::view&lt;V&gt;</computeroutput>. Additionally, the value type of <computeroutput>V</computeroutput> must be <computeroutput>char</computeroutput>, <computeroutput>wchar_t</computeroutput>, <computeroutput>char8_t</computeroutput>, <computeroutput>char16_t</computeroutput>, or <computeroutput>char32_t</computeroutput>. </para></purpose></template-nontype-parameter>
    </template><description><para>A view that produces UTF-16 from an given sequence of UTF.</para><para>
</para></description><method-group name="public member functions">
</method-group>
<constructor cv="= default"/>
<constructor><parameter name="base"><paramtype>V</paramtype></parameter></constructor>
</class><class name="utf32_view"><template>
      <template-nontype-parameter name="V"><type><emphasis>unspecified</emphasis></type><purpose><para>Constrained by <computeroutput>std::ranges::view&lt;V&gt;</computeroutput>. Additionally, the value type of <computeroutput>V</computeroutput> must be <computeroutput>char</computeroutput>, <computeroutput>wchar_t</computeroutput>, <computeroutput>char8_t</computeroutput>, <computeroutput>char16_t</computeroutput>, or <computeroutput>char32_t</computeroutput>. </para></purpose></template-nontype-parameter>
    </template><description><para>A view that produces UTF-32 from an given sequence of UTF.</para><para>
</para></description><method-group name="public member functions">
</method-group>
<constructor cv="= default"/>
<constructor><parameter name="base"><paramtype>V</paramtype></parameter></constructor>
</class><class name="utf8_view"><template>
      <template-nontype-parameter name="V"><type><emphasis>unspecified</emphasis></type><purpose><para>Constrained by <computeroutput>std::ranges::view&lt;V&gt;</computeroutput>. Additionally, the value type of <computeroutput>V</computeroutput> must be <computeroutput>char</computeroutput>, <computeroutput>wchar_t</computeroutput>, <computeroutput>char8_t</computeroutput>, <computeroutput>char16_t</computeroutput>, or <computeroutput>char32_t</computeroutput>. </para></purpose></template-nontype-parameter>
    </template><description><para>A view that produces UTF-8 from an given sequence of UTF.</para><para>
</para></description><method-group name="public member functions">
</method-group>
<constructor cv="= default"/>
<constructor><parameter name="base"><paramtype>V</paramtype></parameter></constructor>
</class><typedef name="format"><type><emphasis>unspecified</emphasis></type></typedef>
<data-member name="as_utf8"><type><classname>constexpr</classname> <classname>auto</classname></type><description><para>A view adaptor that produces a <computeroutput><classname alt="boost::parser::utf8_view">utf8_view</classname></computeroutput> of the given view. </para></description></data-member>
<data-member name="as_utf16"><type><classname>constexpr</classname> <classname>auto</classname></type><description><para>A view adaptor that produces a <computeroutput><classname alt="boost::parser::utf16_view">utf16_view</classname></computeroutput> of the given view. </para></description></data-member>
<data-member name="as_utf32"><type><classname>constexpr</classname> <classname>auto</classname></type><description><para>A view adaptor that produces a <computeroutput><classname alt="boost::parser::utf32_view">utf32_view</classname></computeroutput> of the given view. </para></description></data-member>



















































































</namespace>
</namespace>
</header>
<header name="boost/parser/transform_replace.hpp">
<namespace name="boost">
<namespace name="parser">
<struct name="transform_replace_view"><template>
      <template-nontype-parameter name="V"><type>std::ranges::viewable_range</type></template-nontype-parameter>
      <template-nontype-parameter name="F"><type>std::move_constructible</type></template-nontype-parameter>
      <template-type-parameter name="Parser"/>
      <template-type-parameter name="GlobalState"/>
      <template-type-parameter name="ErrorHandler"/>
      <template-type-parameter name="SkipParser"/>
    </template><description><para>Produces a range of subranges of a given range <computeroutput>base</computeroutput>. Each subrange is either a subrange of <computeroutput>base</computeroutput> that does not match the given parser <computeroutput>parser</computeroutput>, or is <computeroutput>f(*boost::parser::parse(match, parser))</computeroutput>, where <computeroutput>f</computeroutput> is the given invocable and <computeroutput>match</computeroutput> is the matching subrange.</para><para>In addition to the template parameter constraints, <computeroutput>F</computeroutput> must be invocable with the attribute type of <computeroutput>Parser</computeroutput>; <computeroutput>V</computeroutput> and the range type produced by <computeroutput>F</computeroutput>, "`Rf`" must be ranges of <computeroutput>char</computeroutput>, or must have the same UTF format; and <computeroutput>V</computeroutput> and <computeroutput>Rf</computeroutput> must meet the same compatibility requirements as described in <computeroutput>std::ranges::join_view</computeroutput>. </para></description><struct name="iterator"><template>
      <template-nontype-parameter name="Const"><type><classname>bool</classname></type></template-nontype-parameter>
    </template><typedef name="I"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="S"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="ref_t_iter"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="reference_type"><type>BOOST_PARSER_SUBRANGE&lt; ref_t_iter &gt;</type></typedef>
<typedef name="base_type"><type><emphasis>unspecified</emphasis></type></typedef>
<method-group name="public member functions">
<method name="operator++"><type><classname>constexpr</classname> <classname>iterator</classname> &amp;</type></method>
<method name="operator*" cv="const"><type><classname>constexpr</classname> reference_type</type></method>
</method-group>
<constructor cv="= default"/>
<constructor><parameter name="parent"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></constructor>
</struct><struct name="sentinel"><template>
      <template-nontype-parameter name="Const"><type><classname>bool</classname></type></template-nontype-parameter>
    </template></struct><method-group name="public member functions">
<method name="base" cv="const"><type><classname>constexpr</classname> V</type></method>
<method name="base"><type><classname>constexpr</classname> V</type></method>
<method name="f" cv="const"><type><classname>constexpr</classname> F <classname>const</classname> &amp;</type></method>
<method name="begin"><type><classname>constexpr</classname> <classname>auto</classname></type></method>
<method name="end"><type><classname>constexpr</classname> <classname>auto</classname></type></method>
<method name="begin" cv="const"><type><classname>constexpr</classname> <classname>auto</classname></type></method>
<method name="end" cv="const"><type><classname>constexpr</classname> <classname>auto</classname></type></method>
</method-group>
<constructor cv="= default"/>
<constructor><parameter name="base"><paramtype>V</paramtype></parameter><parameter name="parser"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="skip"><paramtype><classname>parser_interface</classname>&lt; <classname>SkipParser</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="f"><paramtype>F</paramtype></parameter><parameter name="trace_mode"><paramtype>trace</paramtype><default>trace::off</default></parameter></constructor>
<constructor><parameter name="base"><paramtype>V</paramtype></parameter><parameter name="parser"><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt; <classname>const</classname> &amp;</paramtype></parameter><parameter name="f"><paramtype>F</paramtype></parameter><parameter name="trace_mode"><paramtype>trace</paramtype><default>trace::off</default></parameter></constructor>
</struct><data-member name="transform_replace"><type><emphasis>unspecified</emphasis></type><description><para>A range adaptor object ([range.adaptor.object]). Given subexpressions <computeroutput>E</computeroutput> and <computeroutput>P</computeroutput>, <computeroutput>Q</computeroutput>, <computeroutput>R</computeroutput>, and 'S', each of the expressions <computeroutput>replace(E,
P)</computeroutput>, <computeroutput>replace(E, P, Q)</computeroutput>. <computeroutput>replace(E, P, Q, R)</computeroutput>, and <computeroutput>replace(E, P, Q,
R, S)</computeroutput> are expression-equivalent to <computeroutput>replace_view(E, P)</computeroutput>, <computeroutput>replace_view(E, P, Q)</computeroutput>, <computeroutput>replace_view(E, P, Q, R)</computeroutput>, <computeroutput>replace_view(E,
P, Q, R, S)</computeroutput>, respectively. </para></description></data-member>

<function name="transform_replace_view"><type/><template>
          <template-type-parameter name="V"/>
          <template-type-parameter name="F"/>
          <template-type-parameter name="Parser"/>
          <template-type-parameter name="GlobalState"/>
          <template-type-parameter name="ErrorHandler"/>
          <template-type-parameter name="SkipParser"/>
        </template><parameter name=""><paramtype>V &amp;&amp;</paramtype></parameter><parameter name=""><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt;</paramtype></parameter><parameter name=""><paramtype><classname>parser_interface</classname>&lt; <classname>SkipParser</classname> &gt;</paramtype></parameter><parameter name=""><paramtype>F &amp;&amp;</paramtype></parameter><parameter name=""><paramtype>trace</paramtype></parameter></function>
<function name="transform_replace_view"><type/><template>
          <template-type-parameter name="V"/>
          <template-type-parameter name="F"/>
          <template-type-parameter name="Parser"/>
          <template-type-parameter name="GlobalState"/>
          <template-type-parameter name="ErrorHandler"/>
          <template-type-parameter name="SkipParser"/>
        </template><parameter name=""><paramtype>V &amp;&amp;</paramtype></parameter><parameter name=""><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt;</paramtype></parameter><parameter name=""><paramtype><classname>parser_interface</classname>&lt; <classname>SkipParser</classname> &gt;</paramtype></parameter><parameter name=""><paramtype>F &amp;&amp;</paramtype></parameter></function>
<function name="transform_replace_view"><type/><template>
          <template-type-parameter name="V"/>
          <template-type-parameter name="F"/>
          <template-type-parameter name="Parser"/>
          <template-type-parameter name="GlobalState"/>
          <template-type-parameter name="ErrorHandler"/>
        </template><parameter name=""><paramtype>V &amp;&amp;</paramtype></parameter><parameter name=""><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt;</paramtype></parameter><parameter name=""><paramtype>F &amp;&amp;</paramtype></parameter><parameter name=""><paramtype>trace</paramtype></parameter></function>
<function name="transform_replace_view"><type/><template>
          <template-type-parameter name="V"/>
          <template-type-parameter name="F"/>
          <template-type-parameter name="Parser"/>
          <template-type-parameter name="GlobalState"/>
          <template-type-parameter name="ErrorHandler"/>
        </template><parameter name=""><paramtype>V &amp;&amp;</paramtype></parameter><parameter name=""><paramtype><classname>parser_interface</classname>&lt; <classname>Parser</classname>, <classname>GlobalState</classname>, <classname>ErrorHandler</classname> &gt;</paramtype></parameter><parameter name=""><paramtype>F &amp;&amp;</paramtype></parameter></function>














































































</namespace>
</namespace>
</header>
<header name="boost/parser/tuple.hpp">
<namespace name="boost">
<namespace name="parser">
<namespace name="literals">
<function name="operator&quot;&quot;_c"><type><classname>constexpr</classname> <classname>auto</classname></type><template>
          <template-nontype-parameter name="chars"><type>char...</type></template-nontype-parameter>
        </template><description><para>A literal that can be used to concisely name <computeroutput>parser::llong</computeroutput> integral constants. </para></description></function>












</namespace>
<typedef name="tuple"><description><para>The tuple template alias used within Boost.Parser. This will be <computeroutput>boost::hana::tuple</computeroutput> if <computeroutput>BOOST_PARSER_USE_HANA_TUPLE</computeroutput> is defined, and <computeroutput>std::tuple</computeroutput> otherwise. </para></description><type>hana::tuple&lt; Args... &gt;</type></typedef>
<typedef name="integral_constant"><description><para>A template alias that is <computeroutput>boost::hana::integral_constant&lt;T, I&gt;</computeroutput> if <computeroutput>BOOST_PARSER_USE_HANA_TUPLE</computeroutput> is defined, and <computeroutput>std::integral_constant&lt;T, I&gt;</computeroutput> otherwise. </para></description><type>hana::integral_constant&lt; <classname>T</classname>, I &gt;</type></typedef>
<typedef name="llong"><description><para>A template alias that is <computeroutput>boost::hana::llong&lt;I&gt;</computeroutput> if <computeroutput>BOOST_PARSER_USE_HANA_TUPLE</computeroutput> is defined, and <computeroutput>std::integral_constant&lt;long long, I&gt;</computeroutput> otherwise. </para></description><type>integral_constant&lt; <classname>long</classname> <classname>long</classname>, I &gt;</type></typedef>
<function name="get"><type><classname>constexpr</classname> <classname>decltype</classname>(<classname>auto</classname>)</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
          <template-nontype-parameter name="I"><type>U</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype><classname>T</classname> &amp;&amp;</paramtype></parameter><parameter name="i"><paramtype>integral_constant&lt; <classname>U</classname>, I &gt;</paramtype></parameter><description><para>An accessor that returns a reference to the <computeroutput>I</computeroutput>-th data member of an aggregate struct or <computeroutput>boost::parser::tuple</computeroutput>. </para></description></function>


















































































</namespace>
</namespace>
</header>
</library-reference>